{"root":{"data":{"id":"dew0hz8ebvk0","created":1765519695609,"text":"设计模式","expandState":"expand"},"children":[{"data":{"id":"ddfd2mezovc0","created":1760172488973,"text":"工厂设计模式","layout":null},"children":[{"data":{"id":"ddfd2pxsv8w0","created":1760172496640,"text":"简单工厂模式","layout":null},"children":[{"data":{"id":"ddfd87kqqrc0","created":1760172926854,"text":"所有产品共用一个工厂，如果新增产品，则需要修改代码，违反开闭原则","layout":null},"children":[]},{"data":{"id":"ddfd8ghdwi00","created":1760172946242,"text":"是一种编程习惯，可以借鉴这种编程思路","layout":null},"children":[]}]},{"data":{"id":"ddfd2zzqxbc0","created":1760172518526,"text":"工厂方法模式","layout":null},"children":[{"data":{"id":"ddfd40e0twg0","created":1760172597753,"text":"优点","expandState":"expand","layout":null},"children":[{"data":{"id":"ddfd376el740","created":1760172534166,"text":"用户只需要知道具体工厂名称就可得到所要的产品，无须知道产品的具体创建过程","layout":null},"children":[]},{"data":{"id":"ddfd3ku2qxs0","created":1760172563895,"text":"在系统增加新产品时只要添加具体产品类和对应的具体工厂类，无须堆原工厂进行修改，满足开闭原则","layout":null},"children":[]}]},{"data":{"id":"ddfd439d3gg0","created":1760172604002,"text":"缺点","layout":null},"children":[{"data":{"id":"ddfd44babbk0","created":1760172606295,"text":"每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类，增加系统复杂度","layout":null},"children":[]}]}]},{"data":{"id":"ddfd8qmilk00","created":1760172968320,"text":"抽象工厂模式","layout":null},"children":[{"data":{"id":"ddfd99gwxo80","created":1760173009340,"text":"抽象工厂模式可以生产多个等级的产品","layout":null},"children":[{"data":{"id":"ddfd9lno8js0","created":1760173035870,"text":"是一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂","layout":null},"children":[]}]}]}]},{"data":{"id":"ddfdgo2dgts0","created":1760173589662,"text":"策略模式"},"children":[{"data":{"id":"ddfdgxr4rk80","created":1760173610750,"text":"该模式定义了一系列算法，把每个算法封装起来，使他们可以相互替换。且算法的变化不会影响使用算法的客户"},"children":[]},{"data":{"id":"ddfdhd230dk0","created":1760173644064,"text":"通过对算法进行封装，并把使用算法的责任和算法的实现分割，并委派给不同的对象对这些算法进行管理"},"children":[]},{"data":{"id":"dexrqnleg7s0","created":1765698105476,"text":"例子"},"children":[{"data":{"id":"dexrqoqvlk00","created":1765698107984,"text":"旅行方式选择：骑自行车、坐汽车等，每种方式都是一个可替换的策略。"},"children":[]}]},{"data":{"id":"ddfdhwi74dk0","created":1760173686397,"text":"优点"},"children":[{"data":{"id":"ddfdhxju40o0","created":1760173688673,"text":"策略类之间可以相互转换"},"children":[]},{"data":{"id":"ddfdi2potsg0","created":1760173699910,"text":"易于扩展"},"children":[]},{"data":{"id":"ddfdi56krk80","created":1760173705285,"text":"避免使用多重条件选择语句（if-else），充分体现面向对象设计思想"},"children":[]}]},{"data":{"id":"ddfdinao34w0","created":1760173744715,"text":"缺点"},"children":[{"data":{"id":"ddfdiuag2y80","created":1760173759939,"text":"客户端必须知道所有的策略类，并自行决定使用哪一个策略类"},"children":[]},{"data":{"id":"ddfdj5ly89c0","created":1760173784579,"text":"策略模式将造成产生很多策略类"},"children":[]}]}]},{"data":{"id":"ddfdtvlo8u00","created":1760174624800,"text":"责任链模式"},"children":[{"data":{"id":"ddfdtzhf3ts0","created":1760174633250,"text":"为了避免请求发送者与多个请求处理者耦合在一起，将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链；当请求发生时，可将请求沿着这条链传递，直到有对象处理"},"children":[]},{"data":{"id":"ddfdw45ssg00","created":1760174800160,"text":"优点"},"children":[{"data":{"id":"ddfdweob2k80","created":1760174823047,"text":"降低对象之间的耦合度"},"children":[]},{"data":{"id":"ddfdwj09s480","created":1760174832477,"text":"增强系统的可扩展性"},"children":[]},{"data":{"id":"ddfdwlzqf8g0","created":1760174838975,"text":"增强给对象指派责任的灵活性"},"children":[]},{"data":{"id":"ddfdwr3jzmo0","created":1760174850090,"text":"责任链简化对象之间的连接"},"children":[]},{"data":{"id":"ddfdwur8x480","created":1760174858053,"text":"责任分担"},"children":[]}]},{"data":{"id":"ddfdwxulmsw0","created":1760174864786,"text":"缺点"},"children":[{"data":{"id":"ddfdx4kgdc00","created":1760174879410,"text":"对比较长的职责链，请求的处理可能涉及多个处理对象，系统性能将受到一定影响·"},"children":[]},{"data":{"id":"ddfdxijiei80","created":1760174909828,"text":"职责链建立的合理性要靠客户端保证，增加客户端的复杂度，可能会由于职责链的错误设置导致系统出错，如可能会造成循环调用"},"children":[]}]}]},{"data":{"id":"dew1bp78j800","created":1765522024696,"text":"备忘录模式"},"children":[{"data":{"id":"dew1c1ddowg0","created":1765522051189,"text":"允许捕获并保存一个对象的内部状态，以便在将来可以恢复到该状态，实现撤销和回滚操作。"},"children":[]},{"data":{"id":"dew1cfye3ww0","created":1765522082934,"text":"只允许发起人查看"},"children":[]},{"data":{"id":"dew1czoxa1s0","created":1765522125898,"text":"优点"},"children":[{"data":{"id":"dew1dje2aig0","created":1765522168777,"text":"提供状态恢复机制：允许用户方便地回到历史状态。"},"children":[]},{"data":{"id":"dew1dmq1sfs0","created":1765522176032,"text":"封装状态信息：用户不需要关心状态的保存细节。"},"children":[]}]},{"data":{"id":"dew1dojvvko0","created":1765522180012,"text":"缺点"},"children":[{"data":{"id":"dew2r7awhcw0","created":1765526060672,"text":"资源消耗：如果对象的状态复杂，保存状态可能会占用较多资源。"},"children":[]}]}]},{"data":{"id":"dew2rbljpzc0","created":1765526070023,"text":"代理模式"},"children":[{"data":{"id":"dew2ruzy1gw0","created":1765526112252,"text":"代理模式解决的是在直接访问某些对象时可能遇到的问题，例如对象创建成本高、需要安全控制或远程访问等。"},"children":[]},{"data":{"id":"dew36j299fk0","created":1765527261733,"text":"例子"},"children":[{"data":{"id":"dew2vfxbx1s0","created":1765526392899,"text":"Spring AOP：使用代理模式来实现面向切面编程。"},"children":[]},{"data":{"id":"dexrskbn18o0","created":1765698255083,"text":"代售点：购买火车票时，代售点作为火车站的代理。"},"children":[]}]},{"data":{"id":"dew2sz7wx1c0","created":1765526199806,"text":"优点"},"children":[{"data":{"id":"dew2t4rogsw0","created":1765526211885,"text":"职责分离：代理模式将访问控制与业务逻辑分离。"},"children":[]},{"data":{"id":"dew2t8prul40","created":1765526220477,"text":"扩展性：可以灵活地添加额外的功能或控制。"},"children":[]},{"data":{"id":"dew2tc0dua80","created":1765526227648,"text":"智能化：可以智能地处理访问请求，如延迟加载、缓存等。"},"children":[]}]},{"data":{"id":"dew2tfdr8r40","created":1765526234987,"text":"缺点"},"children":[{"data":{"id":"dew2tnqsy000","created":1765526253191,"text":"性能开销：增加了代理层可能会影响请求的处理速度。"},"children":[]},{"data":{"id":"dew2trdaki00","created":1765526261081,"text":"实现复杂性：某些类型的代理模式实现起来可能较为复杂。"},"children":[]}]}]},{"data":{"id":"dew30jqte000","created":1765526793033,"text":"单例模式"},"children":[{"data":{"id":"dew30p2q6nc0","created":1765526804637,"text":"确保一个类只有一个实例，并提供一个全局访问点来访问该实例。"},"children":[]},{"data":{"id":"dew36mr231s0","created":1765527269763,"text":"例子"},"children":[{"data":{"id":"dew36nz3nwo0","created":1765527272426,"text":"一个班级只有一个班主任。"},"children":[]},{"data":{"id":"dew36r4y6t40","created":1765527279310,"text":"设备管理器设计为单例模式，例如电脑有两台打印机，避免同时打印同一个文件。"},"children":[]}]},{"data":{"id":"dew3180xo480","created":1765526845888,"text":"优点"},"children":[{"data":{"id":"dew31b47lqo0","created":1765526852616,"text":"内存中只有一个实例，减少内存开销，尤其是频繁创建和销毁实例时（如管理学院首页页面缓存）。"},"children":[]},{"data":{"id":"dew31dacyvc0","created":1765526857342,"text":"避免资源的多重占用（如写文件操作）。"},"children":[]}]},{"data":{"id":"dew31egxcgw0","created":1765526859916,"text":"缺点"},"children":[{"data":{"id":"dew31jg97kg0","created":1765526870759,"text":"没有接口，不能继承。"},"children":[]},{"data":{"id":"dew31m2el2w0","created":1765526876452,"text":"与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心实例化方式。"},"children":[]}]}]},{"data":{"id":"dew36tzq3ns0","created":1765527285526,"text":"迭代器模式","layout":null},"children":[{"data":{"id":"dew36xigt7k0","created":1765527293188,"text":"允许顺序访问一个聚合对象中的元素，同时不暴露对象的内部表示。","layout":null},"children":[]},{"data":{"id":"dew37xdoo0g0","created":1765527371263,"text":"实现方法","expandState":"expand"},"children":[{"data":{"id":"dew378tebyo0","created":1765527317794,"text":"定义迭代器接口：包含hasNext()和next()等方法，用于遍历元素。","layout":null},"children":[]},{"data":{"id":"dew37glqx600","created":1765527334746,"text":"创建具体迭代器：实现迭代器接口，定义如何遍历特定的聚合对象。","layout":null},"children":[]},{"data":{"id":"dew37rrrwo80","created":1765527359055,"text":"聚合类：定义一个接口用于返回一个迭代器对象。"},"children":[]}]},{"data":{"id":"dew38bmmzbs0","created":1765527402280,"text":"例子"},"children":[{"data":{"id":"dew38cmlu7k0","created":1765527404455,"text":"Java中的Iterator：Java集合框架中的迭代器用于遍历集合元素。"},"children":[]}]},{"data":{"id":"dew38ebvsu80","created":1765527408160,"text":"优点"},"children":[{"data":{"id":"dew38h4a7o00","created":1765527414231,"text":"支持多种遍历方式：不同的迭代器可以定义不同的遍历方式。"},"children":[]},{"data":{"id":"dew38k9qdqw0","created":1765527421090,"text":"简化聚合类：聚合类不需要关心遍历逻辑。"},"children":[]},{"data":{"id":"dew38p8hljs0","created":1765527431899,"text":"多遍历支持：可以同时对同一个聚合对象进行多次遍历。"},"children":[]},{"data":{"id":"dew38sumg8w0","created":1765527439768,"text":"扩展性：增加新的聚合类和迭代器类都很方便，无需修改现有代码。"},"children":[]}]},{"data":{"id":"dew38u5kfm80","created":1765527442606,"text":"缺点"},"children":[{"data":{"id":"dew38ysdbqw0","created":1765527452692,"text":"系统复杂性：每增加一个聚合类，就需要增加一个对应的迭代器类，增加了类的数量。"},"children":[]}]}]},{"data":{"id":"dew3h24lbfc0","created":1765528086875,"text":"访问者模式"},"children":[{"data":{"id":"dew3hxaas280","created":1765528154700,"text":"在将数据结构与在该数据结构上执行的操作分离，从而使得添加新的操作变得更容易，而无需修改数据结构本身。"},"children":[]},{"data":{"id":"dew3r2vsy5s0","created":1765528872162,"text":"例子"},"children":[{"data":{"id":"dew3r3svexc0","created":1765528874162,"text":"做客场景：访问者（如您）访问朋友家，朋友作为元素提供信息，访问者根据信息做出判断。"},"children":[]}]},{"data":{"id":"dew3ijwh8d40","created":1765528203931,"text":"优点"},"children":[{"data":{"id":"dew3ipsjwgw0","created":1765528216754,"text":"单一职责原则：访问者模式符合单一职责原则，每个类只负责一项职责。"},"children":[]},{"data":{"id":"dew3irvtcnk0","created":1765528221305,"text":"扩展性：容易为数据结构添加新的操作。"},"children":[]},{"data":{"id":"dew3ityn5eo0","created":1765528225829,"text":"灵活性：访问者可以独立于数据结构变化。"},"children":[]}]},{"data":{"id":"dew3lw495s00","created":1765528465615,"text":"缺点"},"children":[{"data":{"id":"dew3lyvpjog0","created":1765528471628,"text":"违反迪米特原则：元素需要向访问者公开其内部信息。"},"children":[]},{"data":{"id":"dew3m24hju00","created":1765528478689,"text":"元素类难以变更：元素类需要维持与访问者的兼容。"},"children":[]},{"data":{"id":"dew3m3zwso00","created":1765528482766,"text":"依赖具体类：访问者模式依赖于具体类而不是接口，违反了依赖倒置原则。"},"children":[]}]}]},{"data":{"id":"dew3qs04xk80","created":1765528848479,"text":"观察者模式"},"children":[{"data":{"id":"dew3rcctwio0","created":1765528892783,"text":"创建了对象间的一种一对多的依赖关系，当一个对象状态改变时，所有依赖于它的对象都会得到通知并自动更新。"},"children":[]},{"data":{"id":"dew3rptn6uo0","created":1765528922097,"text":"例子"},"children":[{"data":{"id":"dew3rqye8t40","created":1765528924562,"text":"拍卖系统：拍卖师作为主题，竞价者作为观察者，拍卖价格更新时通知所有竞价者。"},"children":[]}]},{"data":{"id":"dew3s0jtiso0","created":1765528945448,"text":"优点"},"children":[{"data":{"id":"dew3sb259hk0","created":1765528968324,"text":"抽象耦合：观察者和主题之间是抽象耦合的。"},"children":[]},{"data":{"id":"dew3sd6r9i00","created":1765528972956,"text":"触发机制：建立了一套状态改变时的触发和通知机制。"},"children":[]}]},{"data":{"id":"dew3rsroep40","created":1765528928509,"text":"缺点"},"children":[{"data":{"id":"dew3rvcm4v40","created":1765528934128,"text":"性能问题：如果观察者众多，通知过程可能耗时。"},"children":[]},{"data":{"id":"dew3rxuiuxc0","created":1765528939565,"text":"循环依赖：可能导致循环调用和系统崩溃。"},"children":[]},{"data":{"id":"dew3rzkxnm80","created":1765528943339,"text":"缺乏变化详情：观察者不知道主题如何变化，只知道变化发生。"},"children":[]}]}]},{"data":{"id":"dew4384qgn40","created":1765529823956,"text":"解释器模式"},"children":[{"data":{"id":"dew43wxwytc0","created":1765529877963,"text":"定义一种语言的文法表示，并创建一个解释器，该解释器能够解释该语言中的句子。"},"children":[]},{"data":{"id":"dew43yz4g880","created":1765529882390,"text":"例子"},"children":[{"data":{"id":"dew446lmlwg0","created":1765529898988,"text":"SQL解析：解释器模式可以用于解析和执行SQL语句。"},"children":[]},{"data":{"id":"dew448wj98o0","created":1765529904001,"text":"正则表达式：解释器模式可以用于解析和执行正则表达式。"},"children":[]}]},{"data":{"id":"dew44b3n92w0","created":1765529908785,"text":"优点"},"children":[{"data":{"id":"dew44dpreow0","created":1765529914475,"text":"可扩展性好：容易添加新的解释表达式的方式。"},"children":[]},{"data":{"id":"dew44fpu1m80","created":1765529918833,"text":"灵活性：可以根据需要轻松扩展或修改文法。"},"children":[]},{"data":{"id":"dew44hm1oy80","created":1765529922958,"text":"易于实现简单文法：对于简单的语言，实现起来相对容易。"},"children":[]}]},{"data":{"id":"dew44j29hs80","created":1765529926115,"text":"缺点"},"children":[{"data":{"id":"dew44lt2jew0","created":1765529932090,"text":"使用场景有限：只适用于适合使用解释的简单文法。"},"children":[]},{"data":{"id":"dew44nnu5go0","created":1765529936127,"text":"维护困难：对于复杂的文法，维护和扩展变得困难。"},"children":[]},{"data":{"id":"dew44pdlgm00","created":1765529939861,"text":"类膨胀：可能会产生很多类，每个文法规则对应一个类。"},"children":[]},{"data":{"id":"dew44s8m1600","created":1765529946090,"text":"递归调用：解释器模式通常使用递归调用，这可能难以理解和跟踪。"},"children":[]}]}]},{"data":{"id":"dew47q26j8g0","created":1765530176440,"text":"命令模式"},"children":[{"data":{"id":"dew4b3m17600","created":1765530441031,"text":"将请求封装为一个对象，允许用户使用不同的请求对客户端进行参数化"},"children":[]},{"data":{"id":"dew4b5sp2g00","created":1765530445788,"text":"解决在软件系统中请求者和执行者之间的紧耦合问题，特别是在需要对行为进行记录、撤销/重做或事务处理等场景。"},"children":[]},{"data":{"id":"dew4d78m2g00","created":1765530605656,"text":"当需要对行为进行记录、撤销/重做或事务处理时，使用命令模式来解耦请求者和执行者。"},"children":[]},{"data":{"id":"dew4b7cm74g0","created":1765530449169,"text":"例子"},"children":[{"data":{"id":"dew4dngdb3c0","created":1765530640953,"text":"看电视按遥控器按钮，换台的请求和处理解耦"},"children":[]}]},{"data":{"id":"dew4bpu18rk0","created":1765530489404,"text":"优点"},"children":[{"data":{"id":"dew4bqziqjk0","created":1765530491913,"text":"降低耦合度：请求者和执行者之间的耦合度降低。"},"children":[]},{"data":{"id":"dew4buas8bk0","created":1765530499124,"text":"易于扩展：新命令可以很容易地添加到系统中。"},"children":[]}]},{"data":{"id":"dew4bxdq9vs0","created":1765530505833,"text":"缺点"},"children":[{"data":{"id":"dew4byg8ako0","created":1765530508161,"text":"过多命令类：系统可能会有过多的具体命令类，增加系统的复杂度。"},"children":[]}]}]},{"data":{"id":"dew4h03h6n40","created":1765530903564,"text":"模板方法模式"},"children":[{"data":{"id":"dew4h9ggp9s0","created":1765530923940,"text":"解决在多个子类中重复实现相同的方法的问题，通过将通用方法抽象到父类中来避免代码重复。"},"children":[]},{"data":{"id":"dew4hkg4eiw0","created":1765530947864,"text":"例子"},"children":[{"data":{"id":"dew4hll7bz40","created":1765530950348,"text":"造房子的大致流程一致，但后面增加围栏步骤不同"},"children":[]}]},{"data":{"id":"dew4ibvn3j40","created":1765531007576,"text":"优点"},"children":[{"data":{"id":"dew4iee0caw0","created":1765531013040,"text":"封装不变部分：算法的不变部分被封装在父类中。"},"children":[]},{"data":{"id":"dew4ig53fr40","created":1765531016854,"text":"扩展可变部分：子类可以扩展或修改算法的可变部分。"},"children":[]},{"data":{"id":"dew4ihp5txs0","created":1765531020245,"text":"提取公共代码：减少代码重复，便于维护。"},"children":[]}]},{"data":{"id":"dew4iitcuhk0","created":1765531022675,"text":"缺点"},"children":[{"data":{"id":"dew4il5ja480","created":1765531027765,"text":"类数目增加：每个不同的实现都需要一个子类，可能导致系统庞大。"},"children":[]}]}]},{"data":{"id":"dew4h879ico0","created":1765530921207,"text":"桥接模式"},"children":[{"data":{"id":"dew4lvhcmz40","created":1765531285340,"text":"用于将抽象部分与实现部分分离，使得它们可以独立地变化。"},"children":[]},{"data":{"id":"dew4m5v2x480","created":1765531307938,"text":"例子"},"children":[{"data":{"id":"dew4m72ucyo0","created":1765531310584,"text":"墙上的开关：开关（抽象）与内部实现（实现）的分离，用户无需关心开关的内部工作机制。"},"children":[]}]},{"data":{"id":"dew4mavbkew0","created":1765531318836,"text":"优点"},"children":[{"data":{"id":"dew4md0gm6g0","created":1765531323501,"text":"抽象与实现分离：提高了系统的灵活性和可维护性。"},"children":[]},{"data":{"id":"dew4meslovc0","created":1765531327379,"text":"扩展能力强：可以独立地扩展抽象和实现。"},"children":[]},{"data":{"id":"dew4mgttrww0","created":1765531331807,"text":"实现细节透明：用户不需要了解实现细节。"},"children":[]}]},{"data":{"id":"dew4mi8ngwo0","created":1765531334880,"text":"缺点"},"children":[{"data":{"id":"dew4ml6eqds0","created":1765531341274,"text":"理解与设计难度：桥接模式增加了系统的理解与设计难度。"},"children":[]},{"data":{"id":"dew4mn3gciw0","created":1765531345449,"text":"聚合关联：要求开发者在抽象层进行设计与编程。"},"children":[]}]}]},{"data":{"id":"dew4n1gav6w0","created":1765531376701,"text":"适配器模式"},"children":[{"data":{"id":"dew4nch73kw0","created":1765531400700,"text":"将一个类的接口转换为另一个接口，使得原本不兼容的类可以协同工作。"},"children":[]},{"data":{"id":"dew4obqriog0","created":1765531477466,"text":"例子"},"children":[{"data":{"id":"dew4od2qlcw0","created":1765531480367,"text":"有一个音频播放器，它只能播放 MP3 文件。现在，我们需要播放 VLC 和 MP4 文件"},"children":[]}]},{"data":{"id":"dew4p6hdxxs0","created":1765531544379,"text":"优点"},"children":[{"data":{"id":"dew4p8zxfm80","created":1765531549854,"text":"促进了类之间的协同工作，即使它们没有直接的关联。"},"children":[]},{"data":{"id":"dew4paacla00","created":1765531552661,"text":"提高了类的复用性。"},"children":[]},{"data":{"id":"dew4pbkxark0","created":1765531555477,"text":"增加了类的透明度。"},"children":[]},{"data":{"id":"dew4pd8slgo0","created":1765531559097,"text":"提供了良好的灵活性。"},"children":[]}]},{"data":{"id":"dew4pedy6h40","created":1765531561585,"text":"缺点"},"children":[{"data":{"id":"dew4piglwl40","created":1765531570453,"text":"过度使用适配器可能导致系统结构混乱，难以理解和维护。"},"children":[]},{"data":{"id":"dew4pjsgsvs0","created":1765531573347,"text":"在Java中，由于只能继承一个类，因此只能适配一个类，且目标类必须是抽象的。"},"children":[]}]}]},{"data":{"id":"dexr7v4511k0","created":1765696632927,"text":"外观模式"},"children":[{"data":{"id":"dexr99u9oh40","created":1765696743346,"text":"为一个复杂的子系统创建一个一致的高层接口。这样，客户端代码就可以通过这个简化的接口与子系统交互，而不需要了解子系统内部的复杂性。"},"children":[]},{"data":{"id":"dexr9e6h12o0","created":1765696752791,"text":"例子"},"children":[{"data":{"id":"dexr9gveyd40","created":1765696758653,"text":"医院接待：医院的接待人员简化了挂号、门诊、划价、取药等复杂流程。"},"children":[]}]},{"data":{"id":"dexr9m3bcc00","created":1765696770015,"text":"优点"},"children":[{"data":{"id":"dexr9ozjb3s0","created":1765696776316,"text":"减少依赖：客户端与子系统之间的依赖减少。"},"children":[]},{"data":{"id":"dexr9r8fuc00","created":1765696781208,"text":"提高灵活性：子系统的内部变化不会影响客户端。"},"children":[]},{"data":{"id":"dexr9tvrkvc0","created":1765696786972,"text":"增强安全性：隐藏了子系统的内部实现，只暴露必要的操作。"},"children":[]}]},{"data":{"id":"dexr9v1xl9s0","created":1765696789522,"text":"缺点"},"children":[{"data":{"id":"dexr9xolux40","created":1765696795247,"text":"违反开闭原则：对子系统的修改可能需要对外观类进行相应的修改。"},"children":[]}]}]},{"data":{"id":"dexraamhz600","created":1765696823417,"text":"享元模式"},"children":[{"data":{"id":"dexradbxwg80","created":1765696829309,"text":"主要用于减少创建对象的数量，以减少内存占用和提高性能。"},"children":[]},{"data":{"id":"dexrakgvuow0","created":1765696844846,"text":"例子"},"children":[{"data":{"id":"dexranpwp5c0","created":1765696851922,"text":"Java中的String对象：字符串常量池中已经存在的字符串会被复用。"},"children":[]}]},{"data":{"id":"dexraq804u00","created":1765696857369,"text":"优点"},"children":[{"data":{"id":"dexrarco9280","created":1765696859829,"text":"减少内存消耗：通过共享对象，减少了内存中对象的数量。"},"children":[]},{"data":{"id":"dexratgf21k0","created":1765696864408,"text":"提高效率：减少了对象创建的时间，提高了系统效率。"},"children":[]}]},{"data":{"id":"dexravvoqx40","created":1765696869685,"text":"缺点"},"children":[{"data":{"id":"dexrax07b140","created":1765696872135,"text":"增加系统复杂度：需要分离内部状态和外部状态，增加了设计和实现的复杂性。"},"children":[]},{"data":{"id":"dexrayphs1s0","created":1765696875841,"text":"线程安全问题：如果外部状态处理不当，可能会引起线程安全问题。"},"children":[]}]}]},{"data":{"id":"dexrci4iixs0","created":1765696996472,"text":"原型模式"},"children":[{"data":{"id":"dexrcjzdbmo0","created":1765697000515,"text":"实现了一个原型接口，该接口用于创建当前对象的克隆。"},"children":[]},{"data":{"id":"dexrd6o3oo00","created":1765697049900,"text":"例子"},"children":[{"data":{"id":"dexrd7jzsv40","created":1765697051828,"text":"一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。"},"children":[]}]},{"data":{"id":"dexrdaxtxcg0","created":1765697059195,"text":"优点"},"children":[{"data":{"id":"dexrdbza6w00","created":1765697061460,"text":"性能提高"},"children":[]},{"data":{"id":"dexrddhuhag0","created":1765697064759,"text":"避免构造函数的约束"},"children":[]}]},{"data":{"id":"dexrdgb46e00","created":1765697070882,"text":"缺点"},"children":[{"data":{"id":"dexrdhpyxo00","created":1765697073957,"text":"配备克隆方法需要全面考虑类的功能，对已有类可能较难实现，特别是处理不支持串行化的间接对象或含有循环结构的引用时。"},"children":[]},{"data":{"id":"dexrdjg6elk0","created":1765697077719,"text":"必须实现 Cloneable 接口。"},"children":[]}]}]},{"data":{"id":"dexrg2ogeo80","created":1765697276306,"text":"中介者模式"},"children":[{"data":{"id":"dexrgcurff40","created":1765697298455,"text":"通过引入一个中介者对象来封装和协调多个对象之间的交互，从而降低对象间的耦合度。"},"children":[]},{"data":{"id":"dexrhewiylc0","created":1765697381280,"text":"例子"},"children":[{"data":{"id":"dexrhgplk800","created":1765697385215,"text":"到一个全新的城市，可以找中介去介绍房子"},"children":[]}]},{"data":{"id":"dexrhpwzi000","created":1765697405252,"text":"优点"},"children":[{"data":{"id":"dexrhrlk7rs0","created":1765697408915,"text":"降低复杂度：将多个对象间的一对多关系转换为一对一关系。"},"children":[]},{"data":{"id":"dexrhus73i80","created":1765697415847,"text":"解耦：对象之间不再直接引用，通过中介者进行交互。"},"children":[]},{"data":{"id":"dexrhwkud7k0","created":1765697419756,"text":"符合迪米特原则：对象只需知道中介者，不需要知道其他对象。"},"children":[]}]},{"data":{"id":"dexrhz68k0w0","created":1765697425403,"text":"缺点"},"children":[{"data":{"id":"dexri0l5bhc0","created":1765697428481,"text":"中介者复杂性：中介者可能会变得庞大和复杂，难以维护。"},"children":[]}]}]},{"data":{"id":"dexrifxq0ww0","created":1765697461893,"text":"装饰器模式"},"children":[{"data":{"id":"dexriqkknv40","created":1765697485043,"text":"动态地给一个对象添加额外的职责，同时不改变其结构"},"children":[]},{"data":{"id":"dexriu90aw00","created":1765697493051,"text":"例子"},"children":[{"data":{"id":"dexrivfcqtc0","created":1765697495611,"text":"往煎饼里面加各种配料，但总体还是一个煎饼"},"children":[]}]},{"data":{"id":"dexrjajbwfs0","created":1765697528503,"text":"优点"},"children":[{"data":{"id":"dexrjbqd4wo0","created":1765697531105,"text":"低耦合：装饰类和被装饰类可以独立变化，互不影响。"},"children":[]},{"data":{"id":"dexrje36jo00","created":1765697536234,"text":"灵活性：可以动态地添加或撤销功能。"},"children":[]},{"data":{"id":"dexrjg7r5a00","created":1765697540864,"text":"替代继承：提供了一种继承之外的扩展对象功能的方式。"},"children":[]}]},{"data":{"id":"dexrji3xp6g0","created":1765697544987,"text":"缺点"},"children":[{"data":{"id":"dexrjj4dkbc0","created":1765697547190,"text":"复杂性：多层装饰可能导致系统复杂性增加。"},"children":[]}]}]},{"data":{"id":"dexrk95q8co0","created":1765697603868,"text":"状态模式"},"children":[{"data":{"id":"dexrkjj0ws00","created":1765697626440,"text":"在状态模式中，我们创建表示各种状态的对象和一个行为随着状态对象改变而改变的 context 对象。"},"children":[]},{"data":{"id":"dexrkq96w6w0","created":1765697641083,"text":"例子"},"children":[{"data":{"id":"dexrkre27vs0","created":1765697643554,"text":"篮球运动员状态：运动员可以有正常、不正常和超常等状态。"},"children":[]}]},{"data":{"id":"dexrkw614e00","created":1765697653952,"text":"优点"},"children":[{"data":{"id":"dexrkxev3r40","created":1765697656663,"text":"封装状态转换规则：将状态转换逻辑封装在状态对象内部。"},"children":[]},{"data":{"id":"dexrkyv723k0","created":1765697659828,"text":"易于扩展：增加新的状态类不会影响现有代码。"},"children":[]},{"data":{"id":"dexrl0buhwg0","created":1765697663011,"text":"集中状态相关行为：将所有与特定状态相关的行为集中到一个类中。"},"children":[]},{"data":{"id":"dexrl2xzixk0","created":1765697668703,"text":"简化条件语句：避免使用大量的条件语句来切换行为。"},"children":[]},{"data":{"id":"dexrl4h7o3s0","created":1765697672043,"text":"状态共享：允许多个上下文对象共享同一个状态对象。"},"children":[]}]},{"data":{"id":"dexrl78nz000","created":1765697678056,"text":"缺点"},"children":[{"data":{"id":"dexrl87xnxs0","created":1765697680189,"text":"增加类和对象数量：每个状态都需要一个具体的状态类。"},"children":[]},{"data":{"id":"dexrl9krqbc0","created":1765697683142,"text":"实现复杂：模式结构和实现相对复杂。"},"children":[]},{"data":{"id":"dexrlat75rc0","created":1765697685828,"text":"开闭原则支持不足：增加新状态或修改状态行为可能需要修改现有代码。"},"children":[]}]}]},{"data":{"id":"dexro3syghk0","created":1765697905669,"text":"组合模式"},"children":[{"data":{"id":"dexro5djb9c0","created":1765697909090,"text":"组合模式（Composite Pattern），又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。"},"children":[]},{"data":{"id":"dexro76epm00","created":1765697913012,"text":"例子"},"children":[{"data":{"id":"dexroluxm000","created":1765697944970,"text":"分公司和总公司也是一个部分整体的关系"},"children":[]}]},{"data":{"id":"dexrovyykfk0","created":1765697966982,"text":"优点"},"children":[{"data":{"id":"dexrowujrk00","created":1765697968892,"text":"简化客户端代码：客户端可以统一处理所有类型的节点。"},"children":[]},{"data":{"id":"dexrozkjvoo0","created":1765697974817,"text":"易于扩展：可以轻松添加新的叶子类型或树枝类型。"},"children":[]}]},{"data":{"id":"dexrp1uddhs0","created":1765697979765,"text":"缺点"},"children":[{"data":{"id":"dexrp2q50ns0","created":1765697981686,"text":"违反依赖倒置原则：组件的声明是基于具体类而不是接口，这可能导致代码的灵活性降低。"},"children":[]}]}]}]},"template":"right","theme":"fresh-blue-compat","version":"1.4.43"}