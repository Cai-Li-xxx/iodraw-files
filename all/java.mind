{"root":{"data":{"id":"dcae8wihxeg0","created":1756011844024,"text":"java"},"children":[{"data":{"id":"dcae9ekabk80","created":1756011883314,"text":"redis","layout":null,"expandState":"collapse"},"children":[{"data":{"id":"dcae9qjv0dc0","created":1756011909410,"text":"缓存","layout":null,"font-size":12,"expandState":"expand"},"children":[{"data":{"id":"dcae9vaj9hs0","created":1756011919730,"text":"缓存穿透","layout":null,"font-size":12,"expandState":"expand"},"children":[{"data":{"id":"dcaeb8ukjiw0","created":1756012027604,"text":"解释：查询不存在的数据，mysql查询不到也没有缓存，每次请求数据库","font-size":12,"layout":null},"children":[]},{"data":{"id":"dcaed51uwlc0","created":1756012176066,"text":"解决1：缓存空数据","font-size":12,"layout":null,"layout_right_offset":{"x":2,"y":1}},"children":[]},{"data":{"id":"dek2dbifjdk0","created":1764306253256,"text":"解决2：布隆过滤器"},"children":[{"data":{"id":"dek2df3qnk80","created":1764306261075,"text":"优点"},"children":[{"data":{"id":"dek2dlb8ki00","created":1764306274589,"text":"数据检索性能快"},"children":[]},{"data":{"id":"dek2dqpoxb40","created":1764306286347,"text":"占用内存小"},"children":[]}]},{"data":{"id":"dek2dtnywgw0","created":1764306292773,"text":"适用场景"},"children":[{"data":{"id":"dek2dw3egjs0","created":1764306298060,"text":"大数据量的数据检索"},"children":[]},{"data":{"id":"dek2dxbfto00","created":1764306300723,"text":"容忍一定误判性"},"children":[]}]}]}]},{"data":{"id":"dcaeag1fhe80","created":1756011964892,"text":"缓存击穿","font-size":12,"layout":null,"expandState":"expand"},"children":[{"data":{"id":"dcaee5ly4yw0","created":1756012255644,"text":"解释：key过期时间到，大量请求并发到数据库","font-size":12,"layout":null},"children":[]},{"data":{"id":"dcaef5y65i80","created":1756012334748,"text":"解决1：互斥锁（强一致、性能差）","font-size":12,"layout":null},"children":[]},{"data":{"id":"dek2qigwb340","created":1764307287135,"text":"解决2：逻辑过期（高可用、性能优）"},"children":[{"data":{"id":"dek2qjzib0w0","created":1764307290437,"text":"1、发现逻辑时间过期"},"children":[]},{"data":{"id":"dek2quu9eo80","created":1764307314065,"text":"2、开启互斥锁"},"children":[]},{"data":{"id":"dek2r07vzm00","created":1764307325772,"text":"3、创建一个新线程进行获取数据并重置逻辑时间"},"children":[]},{"data":{"id":"dek2rdmue3k0","created":1764307354975,"text":"4、在新线程弄好之前返回的是过期的数据"},"children":[]}]}]},{"data":{"id":"dcaeah1kxlk0","created":1756011967078,"text":"缓存雪崩","font-size":12,"layout":null},"children":[{"data":{"id":"dcaeh2284ko0","created":1756012483014,"text":"解释：同一时间key失效或者redis服务器宕机，大量数据请求到数据库","font-size":12,"layout":null},"children":[]},{"data":{"id":"dcaeiqnmj6o0","created":1756012614915,"text":"解决1：给不同key设置不同TTL（生存时间）","font-size":12,"layout":null},"children":[]},{"data":{"id":"dek2smfx6ow0","created":1764307452512,"text":" 解决2：利用Redis集群 "},"children":[{"data":{"id":"dek2ticp6vk0","created":1764307521974,"text":"哨兵模式"},"children":[]},{"data":{"id":"dek2tk369tk0","created":1764307525751,"text":"集群模式"},"children":[]}]},{"data":{"id":"dek2spqr8480","created":1764307459697,"text":"解决3：给缓存业务添加降级限流策略"},"children":[{"data":{"id":"dek2todndw00","created":1764307535092,"text":"nginx"},"children":[]},{"data":{"id":"dek2tqdmfe00","created":1764307539444,"text":"spring cloud gateway"},"children":[]}]},{"data":{"id":"dek2swd08gw0","created":1764307474103,"text":"解决4：给业务添加多级缓存"},"children":[{"data":{"id":"dek2u0l93rc0","created":1764307561673,"text":"Guava"},"children":[]},{"data":{"id":"dek2u2h34f40","created":1764307565775,"text":"Caffeine"},"children":[]}]}]},{"data":{"id":"dcaekn874fk0","created":1756012764180,"text":"双写一致性","font-size":12,"layout":null},"children":[{"data":{"id":"dcael0eik6w0","created":1756012792860,"text":"解释：修改数据库也要更新缓存数据，数据保持一致","font-size":12,"layout":null},"children":[]},{"data":{"id":"dcaeo780oug0","created":1756013042797,"text":"解决1：延迟双删，删  缓存-数据库-缓存（脏数据风险）","font-size":12,"layout":null},"children":[]},{"data":{"id":"dek37wlqcuo0","created":1764308650093,"text":" 解决2：redisson读写锁-强一致性（共享锁、排他锁setnx，保持一个线程在操作）"},"children":[]},{"data":{"id":"dek38ghxcwg0","created":1764308693399,"text":"解决3：异步通知-延时一致（MQ中间件数据更新通知缓存删除、canal中间件读取binlog数据更新缓存）"},"children":[]}]},{"data":{"id":"dcaeuy5x2vk0","created":1756013571629,"text":"数据持久化（通常结合两者）","font-size":12,"layout":null},"children":[{"data":{"id":"dcaevcjr3m00","created":1756013602940,"text":"解决1：RDB","font-size":12,"layout":null},"children":[{"data":{"id":"dcaevr7mpo00","created":1756013634859,"text":"解释：数据存储到磁盘中，故障后从磁盘恢复数据","font-size":12,"layout":null},"children":[]}]},{"data":{"id":"dcaex8x4v7c0","created":1756013751770,"text":"解决2：AOF","font-size":12,"layout":null},"children":[{"data":{"id":"dcaexf2ncoo0","created":1756013765164,"text":"解释：Redis处理的写命令记录在AOF文件    everysec：每秒刷盘","font-size":12,"layout":null},"children":[]}]}]},{"data":{"id":"dcaezgg9w000","created":1756013924893,"text":"数据过期策略（结合两者）","font-size":12,"layout":null},"children":[{"data":{"id":"dcaeztn9og00","created":1756013953615,"text":"惰性删除","font-size":12,"layout":null},"children":[{"data":{"id":"dcaf04h7cow0","created":1756013977192,"text":"解释：key过期时间到，用到key时检查是否过期，过期则删除，反之返回key","font-size":12,"layout":null},"children":[]}]},{"data":{"id":"dcaf0vgkzco0","created":1756014035928,"text":"定期删除","font-size":12,"layout":null},"children":[{"data":{"id":"dcaf0yn5oyg0","created":1756014042856,"text":"解释：一段时间检查key，删除过期key     模式1：SLOW模式（定时任务）  模式2：FAST模式","font-size":12,"layout":null},"children":[]}]}]},{"data":{"id":"dcaf31c81wo0","created":1756014205453,"text":"数据淘汰策略（8种淘汰策略）","font-size":12,"layout":null},"children":[{"data":{"id":"dcaf55ozyps0","created":1756014371661,"text":"LRU算法（最近最少使用）","font-size":12,"layout":null},"children":[]},{"data":{"id":"dcaf5agv4ew0","created":1756014382053,"text":"LFU算法（最少频率使用）","font-size":12,"layout":null},"children":[]}]}]},{"data":{"id":"dcbdmtrlu3s0","created":1756111673989,"text":"主从同步（高并发）","layout":null,"expandState":"expand"},"children":[{"data":{"id":"dcbdogak8z40","created":1756111801389,"text":"全量同步","layout":null},"children":[{"data":{"id":"dcbdu6m3bsg0","created":1756112250503,"text":"解释：从节点请求主节点同步数据（replication id(数据集标记)、offset(偏移量)，主节点判断是否第一次请求，第一次请求就执行bgsave，传RDB文件）","layout":null},"children":[]}]},{"data":{"id":"dcbdoiedja80","created":1756111805973,"text":"增量同步","layout":null},"children":[{"data":{"id":"dcbe03kerog0","created":1756112714056,"text":"解释：从节点请求主节点同步数据，主节点判断是否第一次请求，不是就获取从节点的offset值，主节点根据offset值获取之后的数据进行数据同步","layout":null},"children":[]}]}]},{"data":{"id":"dcbexd6q4rk0","created":1756115321014,"text":"哨兵模式（高可用）","layout":null},"children":[{"data":{"id":"dcbexg8fy8o0","created":1756115327648,"text":"解释：实现主从集群的自动故障恢复（监控、自动故障恢复、通知）","layout":null},"children":[]},{"data":{"id":"dcbezw2asyw0","created":1756115518834,"text":"集群脑裂","layout":null},"children":[{"data":{"id":"dcbezyje3sw0","created":1756115524221,"text":"解释：主从节点和sentinel（哨兵）处于不同网络分区，使得哨兵感觉不到主节点，从而提升一个从节点为主，出现两个master，当网络恢复后，sentinel将老的主节点将为从节点，并从新master同步数据，从而导致数据丢失","layout":null},"children":[]},{"data":{"id":"dcbf1i6z5iw0","created":1756115645370,"text":"解决：修改redis的配置，设置最少从节点数量和缩短主从数据同步的延迟时间，达不到就拒绝请求，避免大量数据丢失","layout":null},"children":[]}]}]},{"data":{"id":"dcbf2valyzs0","created":1756115752252,"text":"分片集群结构（海量数据存储、高并发写）","layout":null},"children":[{"data":{"id":"dcbf3jt6jq80","created":1756115805618,"text":"海量存储解释：集群中有多个master，每个master保存不同数据","layout":null},"children":[]},{"data":{"id":"dcbf430ywh40","created":1756115847447,"text":"高并发写：每个master都有多个slave节点","layout":null},"children":[]}]}]},{"data":{"id":"dcjwo5nos2w0","created":1756977858980,"text":"MySQL","expandState":"collapse","layout":null},"children":[{"data":{"id":"dcjwqn6a2140","created":1756978053837,"text":"优化","expandState":"expand","layout":null},"children":[{"data":{"id":"dcjwqtogwu80","created":1756978067998,"text":"慢查询","expandState":"expand","layout":null},"children":[{"data":{"id":"dcjwr37e3f40","created":1756978088733,"text":"解释：  页面加载过慢、接口压力测试响应时间过长","layout":null},"children":[]},{"data":{"id":"dcjwrrxjjkg0","created":1756978142557,"text":"解决方案一： 开源工具——调试工具：Arthas、运维工具：Prometheus、Skywalking","layout":null},"children":[]},{"data":{"id":"dcjwtdrxzkw0","created":1756978268472,"text":"解决方案二： MySQL自带慢日志","layout":null},"children":[]}]},{"data":{"id":"dcjwxub1wns0","created":1756978617913,"text":"语句执行慢如何分析","layout":null},"children":[{"data":{"id":"dcjwxzlw9rc0","created":1756978629452,"text":"采用EXPLAN或者DESC命令获取MySQL如何执行SELECT语句的信息","layout":null},"children":[{"data":{"id":"dcjwzz8zhrs0","created":1756978785400,"text":"通过key和key_len检查是否命中了索引","layout":null},"children":[]},{"data":{"id":"dcjx1bdo5kg0","created":1756978890169,"text":"通过type查看sql是否有优化空间，是否存在全索引扫描或全盘扫描","layout":null},"children":[]},{"data":{"id":"dcjx1yn0n540","created":1756978940800,"text":"通过extra建议判断是否出现回表情况，如果出现尝试添加索引或修改返回字段","layout":null},"children":[]}]}]},{"data":{"id":"dcjx5cf5vmo0","created":1756979205892,"text":"索引","expandState":"expand","layout":null},"children":[{"data":{"id":"dcjx5izm0t40","created":1756979220190,"text":"解释：索引是帮助MySQL高效获取数据的数据结构（有序）","layout":null},"children":[]},{"data":{"id":"dcjx8njmvp40","created":1756979465200,"text":"优势","layout":null},"children":[{"data":{"id":"dcjx8s0ino00","created":1756979474928,"text":"1.  提高数据检索的效率，降低数据库的IO成本（不需要全盘扫描）","layout":null},"children":[]},{"data":{"id":"dcjx9v6gu080","created":1756979560182,"text":"2.  通过索引列对数据进行排序，降低数据排序的成本，降低CPU消耗","layout":null},"children":[]}]},{"data":{"id":"dcjxadejyb40","created":1756979599853,"text":"底层数据结构","layout":null},"children":[{"data":{"id":"dcjxahmron40","created":1756979609057,"text":"MySQL的InnoDB引擎采用B+树的数据结构来存储索引","layout":null},"children":[{"data":{"id":"dcjxbmq5yq80","created":1756979698511,"text":"优势1：阶数更多，路径更短","layout":null},"children":[]},{"data":{"id":"dcjxbxyc3m00","created":1756979722949,"text":"优势2：磁盘读写代价更低，非叶子节点只存储指针，叶子节点存储数据","layout":null},"children":[]},{"data":{"id":"dcjxcjsjdko0","created":1756979770488,"text":"优势3：B+树便于扫库和区间查询，叶子节点是一个双向链表","layout":null},"children":[]}]}]},{"data":{"id":"dcjxdo1hz480","created":1756979858101,"text":"聚簇索引（聚集索引）","layout":null},"children":[{"data":{"id":"dcjxe33jkv40","created":1756979890876,"text":"解释：数据与索引放到一块，B+树的叶子节点保存整行数据，有且只有一个","layout":null},"children":[]}]},{"data":{"id":"dcjxel59isg0","created":1756979930162,"text":"非聚簇索引（二级索引）","layout":null},"children":[{"data":{"id":"dcjxetbgw7s0","created":1756979947952,"text":"解释：数据与索引分开存储，B+树的叶子节点保存对应的主键，可以有多个","layout":null},"children":[]}]},{"data":{"id":"dcjxfi9pd9c0","created":1756980002265,"text":"回表查询","layout":null},"children":[{"data":{"id":"dcjxfli2efk0","created":1756980009301,"text":"解释：通过二级索引找到对应的主键值，到聚集索引中查找整行数据","layout":null},"children":[]}]},{"data":{"id":"dcjxgkfyzn40","created":1756980085361,"text":"覆盖索引","layout":null},"children":[{"data":{"id":"dcjxgndcm2o0","created":1756980091733,"text":"解释：查询使用了索引，返回的列必须在索引中全部能够找到","layout":null},"children":[]},{"data":{"id":"dcjxkfc9kbk0","created":1756980387710,"text":"使用id查询，直接走聚集索引查询，一次索引扫描，直接返回数据，性能高","layout":null},"children":[]},{"data":{"id":"dcjxkyq4r000","created":1756980429907,"text":"如果返回的列中没有创建索引，有可能会触发回表查询，尽量避免使用select *","layout":null},"children":[]},{"data":{"id":"dcjxlla0e5c0","created":1756980478999,"text":"MySQL超大分页","layout":null},"children":[{"data":{"id":"dcjxlt284jk0","created":1756980495942,"text":"解释：在数据量比较大的时候，limit分页查询，需要对数据进行排序，效率低","layout":null},"children":[]},{"data":{"id":"dcjxm6tfdko0","created":1756980525885,"text":"解决：覆盖索引+子查询","layout":null},"children":[]}]}]},{"data":{"id":"dcjxmpbvesw0","created":1756980566182,"text":"创建原则","expandState":"expand","layout":null},"children":[{"data":{"id":"dcjxn2xkh8w0","created":1756980595792,"text":"1.数据量较大，且查询比较频繁的表","layout":null},"children":[]},{"data":{"id":"dcjxne5gka80","created":1756980620214,"text":"2.常作为查询条件、排序、分组的字段","layout":null},"children":[]},{"data":{"id":"dcjxntd31880","created":1756980653327,"text":"3.尽量联合索引","layout":null},"children":[]},{"data":{"id":"dcjxnyygork0","created":1756980665504,"text":"4.要控制索引的数量","layout":null},"children":[]}]},{"data":{"id":"dcjxp0ytosw0","created":1756980748243,"text":"索引失效情况","expandState":"expand","layout":null},"children":[{"data":{"id":"dcjxp6a572w0","created":1756980759812,"text":"1.违反最左前缀法则","layout":null},"children":[]},{"data":{"id":"dcjxp8m8erc0","created":1756980764896,"text":"2.范围查询右边的列，不能使用索引","layout":null},"children":[]},{"data":{"id":"dcjxp8sxy9c0","created":1756980765302,"text":"3.不要在索引列上进行运算操作，索引失效","layout":null},"children":[]},{"data":{"id":"dcjxp8zmlcg0","created":1756980765706,"text":"4.字符串不加单引号，索引失效","expandState":"expand","layout":null},"children":[]},{"data":{"id":"dcjxp95m0gw0","created":1756980766068,"text":"5.以%开头的Like模糊查询，索引失效","layout":null},"children":[]}]}]}]},{"data":{"id":"dcjxykq08eo0","created":1756981496523,"text":"事务","expandState":"expand","layout":null},"children":[{"data":{"id":"dcjy96rm6wo0","created":1756982328151,"text":"特性（ACID）：原子性、一致性、隔离性、持久性","layout":null},"children":[]},{"data":{"id":"dcjybjyaoew0","created":1756982513582,"text":"并发事务","expandState":"expand","layout":null},"children":[{"data":{"id":"dcjybpi2dwo0","created":1756982525661,"text":"产生的问题","layout":null},"children":[{"data":{"id":"dcjybsnp6hs0","created":1756982532532,"text":"脏读：一个事务读到另外一个事务还没有提交的数据","layout":null},"children":[]},{"data":{"id":"dcjyc57e1o00","created":1756982559844,"text":"不可重复读：一个事务先后读取同一条数据，但两次读取的数据不同","layout":null},"children":[]},{"data":{"id":"dcjycgwkbtk0","created":1756982585311,"text":"幻读：一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据存在","layout":null},"children":[]}]},{"data":{"id":"dcjydb9emuw0","created":1756982651391,"text":"解决（使用隔离）","layout":null},"children":[{"data":{"id":"dcjydkzldxc0","created":1756982672565,"text":"READ UNCOMMITTED（未提交读）——不解决任何","layout":null},"children":[]},{"data":{"id":"dcjyemskhxc0","created":1756982754858,"text":"READ COMMITTED（读已提交）——解决脏读","layout":null},"children":[]},{"data":{"id":"dcjyf1xjfnc0","created":1756982787811,"text":"（默认）REPEATABLE READ（可重复读）——解决脏读、不可重复读","layout":null},"children":[]},{"data":{"id":"dcjyfsjajj40","created":1756982845722,"text":"SERIALIZABLE（串行化）——解决所有","layout":null},"children":[]}]}]},{"data":{"id":"dcjygu7hwg80","created":1756982927727,"text":"undo log和redo log","expandState":"expand","layout":null},"children":[{"data":{"id":"dcjyh4xqrcw0","created":1756982951082,"text":"redo log：记录的是数据页的物理变化，服务宕机可用来同步数据","layout":null},"children":[]},{"data":{"id":"dcjyh5h7b6g0","created":1756982952258,"text":"undo log：记录的是逻辑日志，当事务回滚时，通过逆操作恢复原来的数据","layout":null},"children":[]},{"data":{"id":"dcjyh5n6au80","created":1756982952619,"text":"redo log保证事务的持久性，undo log保证事务的原子性和一致性","layout":null},"children":[]}]},{"data":{"id":"dcjymllkmu80","created":1756983379172,"text":"如何保证隔离性（锁+MVCC）","expandState":"expand","layout":null},"children":[{"data":{"id":"dcjymyxuqcg0","created":1756983408212,"text":"MVCC解释：MySQL中的多版本并发控制，指维护一个数据的多个版本，使得读写操作没有冲突","layout":null},"children":[]},{"data":{"id":"dcjynu34lsw0","created":1756983476012,"text":"MVCC第一部分：隐藏字段","layout":null},"children":[{"data":{"id":"dcjyrbyhuk00","created":1756983750006,"text":"trx_id(事务id)，记录每一次操作的事务id，是自增的","layout":null},"children":[]},{"data":{"id":"dcjyrwzizb40","created":1756983795781,"text":"roll_pointer(回滚指针)，指向上一个版本的事务版本记录地址","layout":null},"children":[]}]},{"data":{"id":"dcjysq0gllk0","created":1756983858964,"text":"MVCC第二部分：undo log","layout":null},"children":[{"data":{"id":"dcjywgv1k6w0","created":1756984152502,"text":"回滚日志：存储老版本数据","layout":null},"children":[]},{"data":{"id":"dcjyx0fxmgw0","created":1756984195124,"text":"版本链：多个事务并行操作某一行记录，记录不同事务修改数据的版本，通过roll_pointer指针形成一个链表","layout":null},"children":[]}]},{"data":{"id":"dcjyzyboi3s0","created":1756984425606,"text":"MVCC第三部分：readView","layout":null},"children":[{"data":{"id":"dcjz0fzqks00","created":1756984464066,"text":"根据readView的匹配规则和当前的一些事务id判断该访问哪个版本的数据","layout":null},"children":[]},{"data":{"id":"dcjz0rzx0w80","created":1756984490198,"text":"解决的是一个事务查询选择版本的问题","layout":null},"children":[]},{"data":{"id":"dcjz20ofiv40","created":1756984587459,"text":"不同隔离界别快照读不一样，最终结果也不一样","layout":null},"children":[{"data":{"id":"dcjz29t83yw0","created":1756984607340,"text":"RC：每一次执行快照读时生成ReadView","layout":null},"children":[]},{"data":{"id":"dcjz2kklwi00","created":1756984630763,"text":"RR：仅在事务中第一次执行快照读时生成ReadView，后续复用","layout":null},"children":[]}]}]}]}]},{"data":{"id":"dckld5y5mdk0","created":1757047525354,"text":"主从同步","expandState":"expand","layout":null},"children":[{"data":{"id":"dckldgeiaqo0","created":1757047548111,"text":"核心：二进制日志binlog语句和DML语句","layout":null},"children":[{"data":{"id":"dckldqf8pog0","created":1757047569923,"text":"主库在事务提交时，会把数据变更记录在二进制日志文件Binlog中","layout":null},"children":[]},{"data":{"id":"dckle31fttc0","created":1757047597387,"text":"从库读取主库的二进制日志文件Binlog，写入到从库的中继日志Relay Log","layout":null},"children":[]},{"data":{"id":"dckle33thhk0","created":1757047597531,"text":"从库重做中继日志中的事件，将改变反映他自己的数据","layout":null},"children":[]}]}]},{"data":{"id":"dcklgs9yzkg0","created":1757047809051,"text":"分库分表","expandState":"expand","layout":null},"children":[{"data":{"id":"dcklhdx53kw0","created":1757047856164,"text":"水平分库：将一个库的数据拆分到多个库中（列都一样），解决海量数据存储和高并发的问题","layout":null},"children":[]},{"data":{"id":"dcklhe4r7mw0","created":1757047856624,"text":"水平分表：将一个表的数据拆分到多个表中（可以在通一个库内），解决单表存储和性能的问题","layout":null},"children":[]},{"data":{"id":"dcklhe70cs00","created":1757047856761,"text":"垂直分库：根据业务进行拆分，将不同表拆分到不同库中，高并发下提高磁盘IO和网络连接数","layout":null},"children":[]},{"data":{"id":"dcklheacgb40","created":1757047856962,"text":"垂直分表：冷热数据分离，根据字段属性将不同字段拆分到不同表中，多表互不影响（如将不常用字段单独放在一个表）","layout":null},"children":[]}]}]},{"data":{"id":"dcklncyxz1c0","created":1757048324281,"text":"框架","layout":null,"expandState":"collapse"},"children":[{"data":{"id":"dcklosky9340","created":1757048436628,"text":"Spring","layout":null,"expandState":"expand"},"children":[{"data":{"id":"dckp30z5r0g0","created":1757058015329,"text":"单例bean","layout":null,"expandState":"expand"},"children":[{"data":{"id":"dckp36t4ci80","created":1757058028025,"text":"不是线程安全","layout":null},"children":[]},{"data":{"id":"dckp47fqw400","created":1757058107757,"text":"Spring中有个@Scope注解，默认值为singleton，为单例","layout":null},"children":[]},{"data":{"id":"dckp5ixmhw80","created":1757058211147,"text":"一般在spring的bean中都是注入无状态对象，没有线程安全问题，如果在bean中定义可修改的成员变量，则要考虑线程安全问题，使用多例或者加锁解决","layout":null},"children":[]}]},{"data":{"id":"dckp6kwy02g0","created":1757058293823,"text":"AOP","layout":null},"children":[{"data":{"id":"dckp6mtq2wg0","created":1757058297982,"text":"解释：面向切面编程，用于将那些与业务无关，却对多个对象产生影响的公共行为和逻辑，抽取公共模块复用，降低耦合","layout":null},"children":[]}]},{"data":{"id":"dckp7ba3mg00","created":1757058351215,"text":"实现事务","layout":null},"children":[{"data":{"id":"dckp7gy9el40","created":1757058363560,"text":"通过AOP对方法前后进行拦截，在执行方法前开启事务，在执行完后根据执行情况提交或回滚事务","layout":null},"children":[]}]},{"data":{"id":"dckp87m81bs0","created":1757058421605,"text":"事务失效","layout":null},"children":[{"data":{"id":"dckp92dz3e80","created":1757058488587,"text":"异常捕获处理，自己处理异常没有抛出","layout":null},"children":[{"data":{"id":"dckp9aaouyo0","created":1757058505803,"text":"解决：手动抛出异常","layout":null},"children":[]}]},{"data":{"id":"dckp92jijo80","created":1757058488922,"text":"Spring默认回滚非检查异常，抛出检查异常","layout":null},"children":[{"data":{"id":"dckpb7jcry80","created":1757058656524,"text":"解决：配置rollbackFor属性为Exception","layout":null},"children":[]}]},{"data":{"id":"dckp92mzasg0","created":1757058489131,"text":"非public方法导致事务失效","layout":null},"children":[{"data":{"id":"dckpblh1eu00","created":1757058686859,"text":"解决：将方法改为public","layout":null},"children":[]}]}]},{"data":{"id":"dckpmqbl76g0","created":1757059559419,"text":"bean的生命周期","layout":null},"children":[{"data":{"id":"dckpmt9oq140","created":1757059565835,"text":"1.通过BeanDefinition获取bean的定义信息","layout":null},"children":[]},{"data":{"id":"dckpmtob01k0","created":1757059566719,"text":"2.调用构造函数实例化bean","layout":null},"children":[]},{"data":{"id":"dckpmtr1k5c0","created":1757059566884,"text":"3.bean的依赖注入","layout":null},"children":[]},{"data":{"id":"dckpmtteciw0","created":1757059567027,"text":"4.处理Aware接口","layout":null},"children":[]},{"data":{"id":"dckpmtvm9xs0","created":1757059567161,"text":"5.Bean的后置处理器BeanPostProcessor#before","layout":null},"children":[]},{"data":{"id":"dckpmtxmgfk0","created":1757059567282,"text":"6.初始化方法","layout":null},"children":[]},{"data":{"id":"dckpmtykndc0","created":1757059567340,"text":"7.Bean的后置处理器BeanPostProcessor#after","layout":null},"children":[]},{"data":{"id":"dckpmv3z2pk0","created":1757059569843,"text":"8.销毁bean","layout":null},"children":[]}]},{"data":{"id":"dckpp5cwos00","created":1757059748879,"text":"bean的循环依赖","layout":null},"children":[{"data":{"id":"dckpp9j53bk0","created":1757059757963,"text":"解释：A依赖于B，B依赖于A，注入方式是构造函数","layout":null},"children":[]},{"data":{"id":"dckppj6leiw0","created":1757059778972,"text":"原因：由于bean的生命周期中的构造函数是第一个执行的，spring框架并不能解决构造函数的依赖注入","layout":null},"children":[]},{"data":{"id":"dckppz48jz40","created":1757059813659,"text":"解决：使用@Lazy进行懒加载，什么时候需要对象再进行bean对象的创建","layout":null},"children":[]}]}]},{"data":{"id":"dckprkzqqvk0","created":1757059939640,"text":"SpringMVC","expandState":"expand","layout":null},"children":[{"data":{"id":"dckprpqk0fk0","created":1757059949969,"text":"执行流程","layout":null},"children":[{"data":{"id":"dckpruhwmrc0","created":1757059960329,"text":"1.用户发送出请求到前端控制器DispatcherServlet","layout":null},"children":[]},{"data":{"id":"dckps5o0cw00","created":1757059984643,"text":"2.DispatcherServlet收到请求调用HandlerMapping（处理器映射器）","layout":null},"children":[]},{"data":{"id":"dckpsswndi80","created":1757060035231,"text":"3.HandlerMapping找到具体的处理器，生成处理器对象及处理器拦截器，再一起返回给DispatcherServlet","layout":null},"children":[]},{"data":{"id":"dckptel908o0","created":1757060082431,"text":"4.DispatcherServlet调用HandlerAdapter（处理器适配器）","layout":null},"children":[]},{"data":{"id":"dckpufqd77k0","created":1757060163282,"text":"5.HandlerAdapter经过适配调用具体的处理器（Handler/Controller）","layout":null},"children":[]},{"data":{"id":"dckpv1pobxk0","created":1757060211129,"text":"6.方法上添加了@ResponseBody","layout":null},"children":[]},{"data":{"id":"dckpv97v6qo0","created":1757060227467,"text":"7.通过HttpMessageConverter来返回结果转化为JSON并响应","layout":null},"children":[]}]}]},{"data":{"id":"dckpxx7f4cw0","created":1757060436411,"text":"SpringBoot自动配置原理","expandState":"expand","layout":null},"children":[{"data":{"id":"dckpy5clqi00","created":1757060454138,"text":"项目的引导类中有个@SpringBootApplication，对@SpringBootConfiguration、@EnableAutoConfiguration、@ComponentScan进行封装","layout":null},"children":[]},{"data":{"id":"dckpzvjojl40","created":1757060589527,"text":"@EnableAutoConfiguration是实现自动化配置的核心注解，通过@Import注解导入对应的配置选择器","layout":null},"children":[]},{"data":{"id":"dckq1f61ugw0","created":1757060710602,"text":"条件判断像@ConditionalOnClass注解，判断是否有对应的class文件，如果有则加载该类，把这个配置类的所有Bean放入Spring容器中","layout":null},"children":[]}]},{"data":{"id":"dclex2um0f40","created":1757130898080,"text":"Spring常见注解","expandState":"expand","layout":null},"children":[{"data":{"id":"dclex9g66vs0","created":1757130912445,"text":"@Component、@Controller、@Service、@Repository","layout":null},"children":[{"data":{"id":"dclexvclaao0","created":1757130960117,"text":"使用在类上用于实例化Bean","layout":null},"children":[]}]},{"data":{"id":"dclex9z3p9k0","created":1757130913589,"text":"@Autowired","layout":null},"children":[{"data":{"id":"dcley51ivwg0","created":1757130981216,"text":"使用在字段上用于根据类型依赖注入","layout":null},"children":[]}]},{"data":{"id":"dclexa134gw0","created":1757130913709,"text":"@Qualifier","layout":null},"children":[{"data":{"id":"dcleymcjkyw0","created":1757131018888,"text":"结合@Autowired一起使用用于根据名称进行依赖注入","layout":null},"children":[]}]},{"data":{"id":"dclexa3ymi80","created":1757130913883,"text":"@Scope","layout":null},"children":[{"data":{"id":"dclezetxodc0","created":1757131080889,"text":"标注Bean的作用范围","layout":null},"children":[]}]},{"data":{"id":"dclexa6suco0","created":1757130914055,"text":"@Configuration","layout":null},"children":[{"data":{"id":"dclezx7uteo0","created":1757131120913,"text":"指定当前类是一个Spring配置类，当创建容器时会从该类上加载注解","layout":null},"children":[]}]},{"data":{"id":"dclexa9dp1k0","created":1757130914211,"text":"@ComponentScan","layout":null},"children":[{"data":{"id":"dclf1d647tc0","created":1757131234001,"text":"用于指定Spring在初始化容器时要扫描的包","layout":null},"children":[]}]},{"data":{"id":"dclexabp1c00","created":1757130914351,"text":"@Bean","layout":null},"children":[{"data":{"id":"dclf1nngilc0","created":1757131256817,"text":"使用在方法上，标注将该方法的返回值存储到Spring容器中","layout":null},"children":[]}]},{"data":{"id":"dclexadl3fc0","created":1757130914465,"text":"@Import","layout":null},"children":[{"data":{"id":"dclf22ma6ow0","created":1757131289398,"text":"使用@Import导入的类会被Spring加载到IOC容器中","layout":null},"children":[]}]},{"data":{"id":"dclexdtatog0","created":1757130921946,"text":"@Aspect、@Before、@After、@Around、@Pointcut","layout":null},"children":[{"data":{"id":"dclf2sofzxc0","created":1757131346125,"text":"用于切面编程（AOP）","layout":null},"children":[]}]}]},{"data":{"id":"dclf3jix1200","created":1757131404564,"text":"SpringMVC常见注解","expandState":"expand","layout":null},"children":[{"data":{"id":"dclf3p8b8zs0","created":1757131416983,"text":"@RequestMapping","layout":null},"children":[{"data":{"id":"dclf3wgiepk0","created":1757131432716,"text":"用于映射请求路径，可以定义在类上和方法上。用于类上，则表示类中的所有方法都是以该地址作为父路径","layout":null},"children":[]}]},{"data":{"id":"dclf3pkbt9k0","created":1757131417710,"text":"@RequestBody","layout":null},"children":[{"data":{"id":"dclf4rq7ijk0","created":1757131500783,"text":"注解实现接收http请求的json数据，将json转化为java对象","layout":null},"children":[]}]},{"data":{"id":"dclf3ppyd200","created":1757131418050,"text":"@RequestParam","layout":null},"children":[{"data":{"id":"dclf57u35ug0","created":1757131535846,"text":"指定请求参数的名称","layout":null},"children":[]}]},{"data":{"id":"dclf3pvzemw0","created":1757131418414,"text":"@PathViriable","layout":null},"children":[{"data":{"id":"dclf5icpjfs0","created":1757131558740,"text":"从请求路径中获取请求参数{/user/{id}}，传递给方法的形式参数","layout":null},"children":[]}]},{"data":{"id":"dclf3q257u80","created":1757131418787,"text":"@ResponseBody","layout":null},"children":[{"data":{"id":"dclf661hfg80","created":1757131610304,"text":"注解实现将controller方法返回对象转化为json对象响应给客户端","layout":null},"children":[]}]},{"data":{"id":"dclf3q8b0ao0","created":1757131419159,"text":"@RequestHeader","layout":null},"children":[{"data":{"id":"dclf7l0j0800","created":1757131721262,"text":"获取指定的请求头数据","layout":null},"children":[]}]},{"data":{"id":"dclf3qdtaew0","created":1757131419492,"text":"@RestController","layout":null},"children":[{"data":{"id":"dclf7uw7jc00","created":1757131742769,"text":"@Controller+@ResponseBody","layout":null},"children":[]}]}]},{"data":{"id":"dclf8uhhzo00","created":1757131820243,"text":"Spring Boot常见注解","expandState":"expand","layout":null},"children":[{"data":{"id":"dclf99t7nco0","created":1757131853603,"text":"@SpringBootConfiguration","layout":null},"children":[{"data":{"id":"dclf9h3xt7k0","created":1757131869489,"text":"组合了@Configuration注解，实现配置文件的功能","layout":null},"children":[]}]},{"data":{"id":"dclf9a13e4w0","created":1757131854080,"text":"@EnableAutoConfiguration","layout":null},"children":[{"data":{"id":"dclf9vzapgg0","created":1757131901860,"text":"打开了自动配置的功能，也可以关闭某个自动配置的选项","layout":null},"children":[]}]},{"data":{"id":"dclf9a371e00","created":1757131854207,"text":"@ComponentScan","layout":null},"children":[{"data":{"id":"dclfabwxblc0","created":1757131936546,"text":"Spring组件扫描","layout":null},"children":[]}]}]},{"data":{"id":"dclfk8a3ho80","created":1757132712276,"text":"MyBatis","expandState":"expand","layout":null},"children":[{"data":{"id":"dclfpe2s9b40","created":1757133116716,"text":"执行流程","expandState":"expand","layout":null},"children":[{"data":{"id":"dclfkvgzrbk0","created":1757132762759,"text":"读取MyBatis配置文件：mybatis-config.xml加载运行环境和映射文件","layout":null},"children":[]},{"data":{"id":"dclfkvoqzcg0","created":1757132763228,"text":"构造会话工厂SqlSessionFactory","layout":null},"children":[]},{"data":{"id":"dclfkvuytb40","created":1757132763604,"text":"会话工厂创建SqlSession对象（包含了执行SQL语句的所有方法）","layout":null},"children":[]},{"data":{"id":"dclfkw08vvc0","created":1757132763924,"text":"操作数据库的接口，Executor执行器，同时负责查询缓存的维护","layout":null},"children":[]},{"data":{"id":"dclfkw55mvc0","created":1757132764220,"text":"Executor接口的执行方法中有一个MappedStatement类型的参数，封装了映射信息","layout":null},"children":[]},{"data":{"id":"dclfkw9fc800","created":1757132764479,"text":"输入参数映射","layout":null},"children":[]}]},{"data":{"id":"dclfpksomao0","created":1757133131343,"text":"延迟加载","layout":null},"children":[{"data":{"id":"dclfpullnj40","created":1757133152682,"text":"解释：就是在需要用到数据时才进行加载，不需要用到数据时就不加载数据","layout":null},"children":[]},{"data":{"id":"dclfq80gbc00","created":1757133181878,"text":"Mybatis支持一对一关联对象和一对多关联集合对象的延迟加载","layout":null},"children":[]},{"data":{"id":"dclfs8eb2hs0","created":1757133339444,"text":"在Mybatis配置文件中，可以配置是否启用延迟加载lazyLoadingEnabled=true|false，默认是关闭的","layout":null},"children":[]}]},{"data":{"id":"dclftkr39c00","created":1757133444703,"text":"底层原理","layout":null},"children":[{"data":{"id":"dclfu0nuab40","created":1757133479335,"text":"使用CGLIB创建目标对象的代理对象","layout":null},"children":[]},{"data":{"id":"dclfu16mb2o0","created":1757133480470,"text":"当调用目标方法，进入拦截器invoke方法，发现目标方法是null值，执行sql查询","layout":null},"children":[]},{"data":{"id":"dclfu1b9auw0","created":1757133480751,"text":"获取数据以后，调用set方法设置属性值，再继续查询目标方法，就有值了","layout":null},"children":[]}]},{"data":{"id":"dclg7y48os00","created":1757134570894,"text":"缓存","layout":null},"children":[{"data":{"id":"dclg80quzw80","created":1757134576616,"text":"一级缓存：基于PerpetualCache的HashMap本地缓存，其存储作用域为Session，当Session进行flush或close之后，该Session中的所有Cache将清空，默认打开一级缓存","layout":null},"children":[]},{"data":{"id":"dclg80z1a9s0","created":1757134577110,"text":"二级缓存：基于namespace和mapper的作用域起作用的，不是依赖于SQL session，默认也是采用PerpetualCache，HashMap存储。需要单独开启，一个是核心配置，一个是mapper映射文件","layout":null},"children":[]},{"data":{"id":"dclga86iejs0","created":1757134749528,"text":"什么时候二级缓存清理缓存中数据","layout":null},"children":[{"data":{"id":"dclgaca7owg0","created":1757134758459,"text":"当某一个作用域（一级缓存 Session/二级缓存Namespaces）的进行了新增、修改、删除操作后，默认该作用域下所有的select中的缓存将被clear","layout":null},"children":[]}]}]}]}]},{"data":{"id":"dcm8tnfiatk0","created":1757215262720,"text":"微服务","expandState":"collapse"},"children":[{"data":{"id":"dclgqqnncps0","created":1757136043573,"text":"SpringCloud","expandState":"expand"},"children":[{"data":{"id":"dclgqz1zluw0","created":1757136061854,"text":"五大组件"},"children":[{"data":{"id":"dclgs7irv9c0","created":1757136158648,"text":"注册中心/配置中心"},"children":[{"data":{"id":"dclgsjc4li80","created":1757136184367,"text":"Nacos"},"children":[]}]},{"data":{"id":"dclgs7q908w0","created":1757136159100,"text":"负载均衡"},"children":[{"data":{"id":"dclgsnsgj9c0","created":1757136194062,"text":"Ribbon"},"children":[]}]},{"data":{"id":"dclgs7uibcg0","created":1757136159357,"text":"服务调用"},"children":[{"data":{"id":"dclgss8vw080","created":1757136203762,"text":"Feign"},"children":[]}]},{"data":{"id":"dclgs7ypl540","created":1757136159611,"text":"服务保护"},"children":[{"data":{"id":"dclgsve8owg0","created":1757136210616,"text":"sentinel"},"children":[]}]},{"data":{"id":"dclgs8188hs0","created":1757136159763,"text":"服务网关"},"children":[{"data":{"id":"dclgsyoll6o0","created":1757136217773,"text":"Gateway"},"children":[]}]}]},{"data":{"id":"dclgtj9016g0","created":1757136262542,"text":"Nacos与Eureka"},"children":[{"data":{"id":"dclgtqa4di00","created":1757136277847,"text":"共同点"},"children":[{"data":{"id":"dclgttuog8w0","created":1757136285621,"text":"都支持服务注册和服务拉取"},"children":[]},{"data":{"id":"dclgtu2e3tk0","created":1757136286087,"text":"都支持服务提供者心跳方式做健康监检测"},"children":[]}]},{"data":{"id":"dclgu9jmvy00","created":1757136319782,"text":"区别"},"children":[{"data":{"id":"dclgubbgkio0","created":1757136323641,"text":"Nacos支持服务端主动检测提供者状态：临时实例采用心跳模式，非临时实例采用主动检测模式"},"children":[]},{"data":{"id":"dclgublprow0","created":1757136324261,"text":"临时实例心跳不正常会被剔除，非临时实例则不会被剔除"},"children":[]},{"data":{"id":"dclgubrbl400","created":1757136324600,"text":"Nacos支持服务列表变更的消息推送模式，服务列表更新更及时"},"children":[]},{"data":{"id":"dclgubx46cg0","created":1757136324950,"text":"Nacos集群默认采用AP方式，当集群中存在非临时实例时，采用CP模式；Eureka采用AP方式"},"children":[]}]},{"data":{"id":"dclgw0nwku80","created":1757136457177,"text":"Nacos支持配置中心，Eureka只有注册中心"},"children":[]}]},{"data":{"id":"dclhdutou8g0","created":1757137855021,"text":"负载均衡","expandState":"expand"},"children":[{"data":{"id":"dclhcz3zjqw0","created":1757137785987,"text":"项目负载均衡如何实现"},"children":[{"data":{"id":"dclhd6oltbk0","created":1757137802471,"text":"主要使用了一个组件Ribbon，比如我们在使用feign远程调用的过程中，底层的负载均衡就是使用了Ribbon"},"children":[]}]},{"data":{"id":"dclhdy4tm680","created":1757137862225,"text":"负载均衡策略"},"children":[{"data":{"id":"dclhefakda80","created":1757137899577,"text":"RoundRobinRule：简单轮询服务列表来选择服务器"},"children":[]},{"data":{"id":"dclhefiww8w0","created":1757137900082,"text":"WeightedResponseTimeRule：按照权重来选择服务器，响应时间越长，权重越小"},"children":[]},{"data":{"id":"dclhefly1nc0","created":1757137900265,"text":"RandomRule：随机选择一个可用的服务器"},"children":[]},{"data":{"id":"dclhefoymq80","created":1757137900448,"text":"ZoneAvoidanceRule：区域敏感策略，以区域可用的服务器为基础进行服务器选择。使用Zone对服务器进行分类，这个Zone可以理解为一个机房、一个机架等，而后再对Zone内的多个服务做轮询（默认）"},"children":[]}]},{"data":{"id":"dclhheg4gjk0","created":1757138132829,"text":"自定义负载均衡策略"},"children":[{"data":{"id":"dclhhigndeo0","created":1757138141568,"text":"创建类实现IRule接口，可以指定负载均衡策略（全局）"},"children":[]},{"data":{"id":"dclhhilqz4w0","created":1757138141876,"text":"在客户端的配置文件中，可以配置某一个服务调用的负载均衡策略（局部）"},"children":[]}]}]},{"data":{"id":"dclmh24h42g0","created":1757152211553,"text":"服务雪崩、熔断、降级"},"children":[{"data":{"id":"dclmh7hhr7c0","created":1757152223224,"text":"服务雪崩"},"children":[{"data":{"id":"dclmhhlzxt40","created":1757152245264,"text":"一个服务失败，导致整条链路的服务都失败的情形"},"children":[]}]},{"data":{"id":"dclmh7plajk0","created":1757152223713,"text":"服务降级"},"children":[{"data":{"id":"dclmhzny4k80","created":1757152284564,"text":"服务自我保护的一种方式，或者保护下游服务的一种方式，用于确保服务不会受到请求突增影响变得不可用，确保服务不会崩溃，一般在实际开发中与feign接口整合，编写降级逻辑"},"children":[]}]},{"data":{"id":"dclmh7rv03k0","created":1757152223851,"text":"服务熔断"},"children":[{"data":{"id":"dclmjeagqlc0","created":1757152394765,"text":"默认关闭，需要手动打开，如果检测到10秒内请求的失败率超过50%，就触发熔断机制。之后每隔5s重新尝试请求微服务，如果微服务不能响应，继续走熔断机制。如果微服务可达，则关闭熔断机制，恢复正常请求"},"children":[]}]}]},{"data":{"id":"dclmmlmi8fc0","created":1757152645823,"text":"skywalking监控"},"children":[{"data":{"id":"dclmmo1nmlc0","created":1757152651092,"text":"skywalking可以监控接口、服务、物理实例的一些状态。特别是在压力测试的时候可以看到众多服务中哪些服务和接口比较慢，我们可以针对性的分析和优化。"},"children":[]},{"data":{"id":"dclmni9yfk00","created":1757152716898,"text":"skywalking设置告警规则，特别是在项目上线以后，如果报错，我们分别设置可以给相关负责人发短信和发邮件，第一时间知道项目的bug情况，第一时间修复"},"children":[]}]}]},{"data":{"id":"dcm8tz760vs0","created":1757215288337,"text":"业务限流"},"children":[{"data":{"id":"dcm8u4fcbgo0","created":1757215299715,"text":"nginx限流"},"children":[{"data":{"id":"dcm8uekqe2w0","created":1757215321809,"text":"控制速率，使用漏桶算法来实现过滤，让请求以固定的速率处理请求，可以应对突发流量"},"children":[]},{"data":{"id":"dcm8uesuo1s0","created":1757215322300,"text":"控制并发数，限制单个IP的链接数和并发链接的总数"},"children":[]}]},{"data":{"id":"dcm8u4ntw2o0","created":1757215300229,"text":"网关限流"},"children":[{"data":{"id":"dcm94iuijz40","created":1757216114749,"text":"在spring cloud gateway中支持局部过滤器RequestRateLimiter来做限流，使用的是令牌桶算法"},"children":[]},{"data":{"id":"dcm94iykitk0","created":1757216114995,"text":"可以根据ip或路径进行限流，可以设置每秒填充平均速率和令牌桶总容量"},"children":[]}]}]},{"data":{"id":"dcmdojbnvow0","created":1757228967509,"text":"分布式系统理论"},"children":[{"data":{"id":"dcmdon7ql680","created":1757228975979,"text":"CAP和BASE"},"children":[{"data":{"id":"dcmdor1w4g00","created":1757228984333,"text":"CAP定理（一致性、可用性、分区容错性）"},"children":[{"data":{"id":"dcmdp43f0mo0","created":1757229012723,"text":"分布式系统节点通过网络连接，一定会出现分区问题（P）"},"children":[]},{"data":{"id":"dcmdp491zkw0","created":1757229013064,"text":"当分区出现时，系统的一致性（C）和可用性（A）就无法同时满足"},"children":[]}]},{"data":{"id":"dcmdppzbpjk0","created":1757229060365,"text":"BASE理论"},"children":[{"data":{"id":"dcmdq9skvf40","created":1757229103493,"text":"基本可用"},"children":[]},{"data":{"id":"dcmdqa0d1vk0","created":1757229103963,"text":"软状态"},"children":[]},{"data":{"id":"dcmdqa6wv4w0","created":1757229104359,"text":"最终一致"},"children":[]}]},{"data":{"id":"dcmdr29m5o00","created":1757229165473,"text":"解决分布式事务的思想和模型"},"children":[{"data":{"id":"dcmdra3mm200","created":1757229182525,"text":"最终一致思想：各分支事务分别执行并提交，如果有不一致的情况，再想办法恢复数据（AP）"},"children":[]},{"data":{"id":"dcmdra9yc680","created":1757229182907,"text":"强一致思想：各分支事务执行完业务不要提交，等待彼此结果。而后统一提交或回滚（CP）"},"children":[]}]}]}]},{"data":{"id":"dcmduuwdczc0","created":1757229462891,"text":"分布式事务解决方案"},"children":[{"data":{"id":"dcmdv3qg7hc0","created":1757229482124,"text":"只要发生多个服务之间的写操作，都需要进行分布式事务控制"},"children":[]},{"data":{"id":"dcmdvg0m67k0","created":1757229508860,"text":"seata的XA模式，CP，需要互相等待各个分支事务提交，可以保证强一致性，性能差"},"children":[{"data":{"id":"dcmdvyd8m5k0","created":1757229548805,"text":"银行业务"},"children":[]}]},{"data":{"id":"dcmdvg6sifs0","created":1757229509234,"text":"seata的AT模式，AP，底层使用undo log实现，性能好"},"children":[{"data":{"id":"dcmeafku01c0","created":1757230683368,"text":"互联网业务"},"children":[]}]},{"data":{"id":"dcmdvgbhc000","created":1757229509517,"text":"seata的TCC模式，AP，性能较好，不过需要人工编码实现"},"children":[{"data":{"id":"dcmelf6pr4o0","created":1757231544520,"text":"银行业务"},"children":[]}]},{"data":{"id":"dcmdvggwl4o0","created":1757229509845,"text":"MQ模式实现分布式事务，在A服务写数据的时候，需要在同一个事务内发送消息到另外一个事务，异步，性能最好"},"children":[{"data":{"id":"dcmhvs8j3m00","created":1757240819902,"text":"互联网业务"},"children":[]}]}]},{"data":{"id":"dcmhwab96200","created":1757240859246,"text":"分布式服务接口幂等性"},"children":[{"data":{"id":"dcmhwg2banc0","created":1757240871767,"text":"幂等：多次调用方法或者接口不会改变业务状态，可以保证重复调用的结果和单次调用的结果一致"},"children":[]},{"data":{"id":"dcmhwxb7u6o0","created":1757240909310,"text":"如果是新增数据，可以使用数据库的唯一索引"},"children":[]},{"data":{"id":"dcmhx67eaqw0","created":1757240928670,"text":"新增或修改数据"},"children":[{"data":{"id":"dcmhxcuocv40","created":1757240943139,"text":"分布式锁，性能较低"},"children":[]},{"data":{"id":"dcmhxd34qv40","created":1757240943650,"text":"使用token+redis来实现，性能较好"},"children":[{"data":{"id":"dcmhxq2s5t40","created":1757240971927,"text":"第一次请求，生成一个唯一token存入redis，返回给前端"},"children":[]},{"data":{"id":"dcmhxq6w0xk0","created":1757240972175,"text":"第二次请求，业务处理，携带之前的token，到redis进行验证，如果存在，可以执行业务，删除token；如果不存在，则直接返回，不处理业务"},"children":[]}]}]}]},{"data":{"id":"dcmi8oevwyo0","created":1757241830311,"text":"xxl-job"},"children":[{"data":{"id":"dcmi8u81e6g0","created":1757241842959,"text":"路由策略：轮询、故障转移、分片广播"},"children":[]},{"data":{"id":"dcmi978kpo00","created":1757241871288,"text":"解决执行失败"},"children":[{"data":{"id":"dcmi9l23kwg0","created":1757241901372,"text":"路由策略选择故障转移，使用健康的实例执行任务"},"children":[]},{"data":{"id":"dcmi9l8761s0","created":1757241901740,"text":"设置重试次数"},"children":[]},{"data":{"id":"dcmi9led85c0","created":1757241902113,"text":"查看日志+邮件告警来通知相关负责人解决"},"children":[]}]},{"data":{"id":"dcmivo356mo0","created":1757243631977,"text":"解决大数据量任务同时执行"},"children":[{"data":{"id":"dcmivtw6go80","created":1757243644616,"text":"让多个实例一块去执行（部署集群），路由策略分片广播"},"children":[]},{"data":{"id":"dcmivu1i06w0","created":1757243644938,"text":"在任务执行的代码中可以获取分片总数和当前分片，按照取模的方式分摊到各个实例执行"},"children":[]}]}]}]},{"data":{"id":"dcn6w3zya600","created":1757311373250,"text":"消息中间件","expandState":"collapse"},"children":[{"data":{"id":"dcn6w6fdvts0","created":1757311378537,"text":"RabbitMQ","layout":null,"expandState":"expand"},"children":[{"data":{"id":"dcn6wo77kg00","created":1757311417225,"text":"如何保证消息不丢失","layout":null},"children":[{"data":{"id":"dcn6wrgpdy80","created":1757311424329,"text":"开启生产者确认机制，确保生产者的消息能到达队列","layout":null},"children":[]},{"data":{"id":"dcn6wrlfll40","created":1757311424615,"text":"开启（交换机、队列、消息）持久化功能，确保消息未消费前在队列不会丢失","layout":null},"children":[]},{"data":{"id":"dcn6wrrjyp40","created":1757311424985,"text":"开启消费者确认机制为auto，由spring确认消息处理成功后完成ack","layout":null},"children":[]},{"data":{"id":"dcn6wrxvqgo0","created":1757311425368,"text":"开启消费者失败重试机制，多次重试失败后将消息投递到异常交换机，交由人工处理","layout":null},"children":[]}]},{"data":{"id":"dcn70ugtpns0","created":1757311744323,"text":"如何解决重复消费问题","layout":null},"children":[{"data":{"id":"dcn712hgty00","created":1757311761776,"text":"每条消息设置一个唯一的标识id","layout":null},"children":[]},{"data":{"id":"dcn712lywcg0","created":1757311762049,"text":"幂等方案：【分布式锁、数据库锁（悲观锁、乐观锁）】","layout":null},"children":[]}]},{"data":{"id":"dcnzlwtdg3k0","created":1757392386160,"text":"死信交换机\\延迟队列","layout":null},"children":[{"data":{"id":"dcnzm5lqo6g0","created":1757392405290,"text":"什么业务用到了延迟队列（超时订单、限时优惠、定时发布）","layout":null},"children":[]},{"data":{"id":"dcnzm5s9tbk0","created":1757392405685,"text":"延迟队列用到了死信交换机和TTL（消息存活时间）实现的","layout":null},"children":[]},{"data":{"id":"dcnzm5wl9280","created":1757392405946,"text":"消息超时未消费就会变成死信（死信的其他情况：拒绝被消费、队列满了）","layout":null},"children":[]},{"data":{"id":"dcnznehg2jk0","created":1757392502986,"text":"延迟队列插件实现延迟队列DelayExchange","layout":null},"children":[{"data":{"id":"dcnznm00sg80","created":1757392519346,"text":"声明一个交换机，添加delayed属性为true","layout":null},"children":[]},{"data":{"id":"dcnznm9qezk0","created":1757392519933,"text":"发送消息时，添加x-delay头，值为超时时间","layout":null},"children":[]}]}]},{"data":{"id":"dcnzwm2tj5s0","created":1757393224793,"text":"如何解决消息堆积","layout":null},"children":[{"data":{"id":"dcnzwrgxx8g0","created":1757393236531,"text":"增加更多消费者，提高消费速度","layout":null},"children":[]},{"data":{"id":"dcnzww2audk0","created":1757393246529,"text":"在消费者内开启线程池加快消息处理速度","layout":null},"children":[]},{"data":{"id":"dcnzx2yphls0","created":1757393261550,"text":"扩大队列容积，提高堆积上限，采用惰性队列","layout":null},"children":[{"data":{"id":"dcnzxc0ll480","created":1757393281255,"text":"在声明队列的时候可以设置属性x-queue-mode为lazy，即为惰性队列","layout":null},"children":[]},{"data":{"id":"dcnzxp1ya1s0","created":1757393309635,"text":"基于磁盘存储，消息上限高","layout":null},"children":[]},{"data":{"id":"dcnzxvjt17s0","created":1757393323775,"text":"性能比较稳定，但基于磁盘存储，受限于磁盘IO，时效性会降低","layout":null},"children":[]}]}]},{"data":{"id":"dco05m2j6ag0","created":1757393930053,"text":"高可用机制","expandState":"expand"},"children":[{"data":{"id":"dco05p6z0tk0","created":1757393936852,"text":"在生产环境下，我们当时采用的镜像模式搭建的集群，共有3个节点"},"children":[]},{"data":{"id":"dco061u37ag0","created":1757393964371,"text":"镜像队列结构是一主多从，所有操作都是主节点完成，然后同步给镜像节点"},"children":[]},{"data":{"id":"dco06fghze00","created":1757393994024,"text":"主节点宕机后，镜像节点会代替成为新的主节点（如果在主从同步完成前，主节点已经宕机，可能会出现数据丢失）"},"children":[]},{"data":{"id":"dco07328j6o0","created":1757394045405,"text":"解决数据丢失：采用仲裁队列，和镜像节点一样都是主从模式，支持主从数据同步，主从同步基于Raft协议，强一致，在声明队列时指定为仲裁队列即可"},"children":[]}]}]},{"data":{"id":"dco0jglp2c80","created":1757395015249,"text":"kafka","expandState":"expand"},"children":[{"data":{"id":"dco0jipkfns0","created":1757395019837,"text":"如何保证消息不丢失"},"children":[{"data":{"id":"dco0jm82xuo0","created":1757395027487,"text":"生产者发送消息到Brocker丢失"},"children":[{"data":{"id":"dco0jwjr1oo0","created":1757395049960,"text":"设置异步发送，发送失败使用回调进行记录或重发"},"children":[]},{"data":{"id":"dco0k5kog3c0","created":1757395069607,"text":"失败重试，参数配置，可以设置重试次数"},"children":[]}]},{"data":{"id":"dco0kbyp1cg0","created":1757395083516,"text":"消息在Brocker中存储丢失"},"children":[{"data":{"id":"dco0khusbi00","created":1757395096340,"text":"发送确认acks，选择all，让所有的副本都参与保存数据后确认"},"children":[]}]},{"data":{"id":"dco0kubx2qw0","created":1757395123497,"text":"消息者从Brocker接收消息丢失"},"children":[{"data":{"id":"dco0l6zhsqo0","created":1757395151044,"text":"关闭自动提交偏移量，开启手动提交偏移量"},"children":[]},{"data":{"id":"dco0q9wo1wg0","created":1757395549224,"text":"提交方式，最好是同步+异步提交"},"children":[]}]}]},{"data":{"id":"dco0qlxciag0","created":1757395575387,"text":"如何解决重复消费问题"},"children":[{"data":{"id":"dco0qph076o0","created":1757395583106,"text":"关闭自动提交偏移量，开启手动提交偏移量"},"children":[]},{"data":{"id":"dco0r0gnlz40","created":1757395607029,"text":"提交方式，最好是同步+异步提交"},"children":[]},{"data":{"id":"dco0r5q5h5k0","created":1757395618487,"text":"幂等方案"},"children":[]}]},{"data":{"id":"dco0rdxv9x40","created":1757395636368,"text":"如何保证消费的顺序性"},"children":[{"data":{"id":"dco0rhtlc680","created":1757395644817,"text":"问题原因：一个topic的数据可能存储在不同分区中，每个分区都有一个按照顺序的存储偏移量，如果消费者关联了多个分区帮你保证顺序性"},"children":[]},{"data":{"id":"dco0s19ss9s0","created":1757395687156,"text":"解决方案"},"children":[{"data":{"id":"dco0s2y7ukg0","created":1757395690809,"text":"发送消息时指定分区号"},"children":[]},{"data":{"id":"dco0s782ki80","created":1757395700112,"text":"发送消息是按照相同的业务设置相同的key"},"children":[]}]}]},{"data":{"id":"dco0z54h6zs0","created":1757396244090,"text":"高可用机制"},"children":[{"data":{"id":"dco0zaeo7yw0","created":1757396255591,"text":"集群：一个kafka集群由多个broker实例组成，即使某一台宕机，也不耽误其他broker继续对外提供服务"},"children":[]},{"data":{"id":"dco1095i8ps0","created":1757396331224,"text":"复制机制"},"children":[{"data":{"id":"dco10b98td40","created":1757396335803,"text":"一个topic有多个分区，每个分区有多个副本，有一个leader，其余的是follower，副本存储在不同的broker中"},"children":[]},{"data":{"id":"dco10w795c80","created":1757396381395,"text":"所有的分区副本的内容是相同的，如果leader发生故障时，会自动将其中一个follower提升为leader，保证系统容错性、高可用性"},"children":[]},{"data":{"id":"dco11fp79kw0","created":1757396423839,"text":"ISR"},"children":[{"data":{"id":"dco11hw7oa00","created":1757396428617,"text":"需要同步复制保存的follower"},"children":[]},{"data":{"id":"dco11zso1cw0","created":1757396467585,"text":"分区副本分为两类，一个是ISR，与leader副本同步保存数据，另外一个普通副本，是异步同步数据，当leader挂掉之后，会优先从ISR副本列表中选取一个作为leader"},"children":[]}]}]}]},{"data":{"id":"dcpz1qpsd5k0","created":1757593925513,"text":"存储结构"},"children":[{"data":{"id":"dcpz1tnuh7k0","created":1757593931926,"text":"Kafka中topic的数据存储在分区上，分区如果文件过大会分段存储segment"},"children":[]},{"data":{"id":"dcpz1tt6fiw0","created":1757593932248,"text":"每个分段都在磁盘上以索引（xxx.index）和日志文件（xxx.log）的形式存储"},"children":[]},{"data":{"id":"dcpz1txnk0o0","created":1757593932519,"text":"分段的好处是，第一能减少单个文件内容的大小，查找数据方便，第二是方便kafka进行日志清理"},"children":[]},{"data":{"id":"dcpz3o9v1dc0","created":1757594076925,"text":"日志清理策略"},"children":[{"data":{"id":"dcpz3rx9mlc0","created":1757594084870,"text":"根据消息的保留时间，当消息保存的时间超过了指定时间，会触发清理，默认是168h"},"children":[]},{"data":{"id":"dcpz468w9080","created":1757594116048,"text":"根据topic存储的数据大小，当topic所占的日志文件大小大于一定的阈值，则开始删除最久的消息（默认关闭）"},"children":[]}]}]},{"data":{"id":"dcpz9l00k3s0","created":1757594539984,"text":"高性能"},"children":[{"data":{"id":"dcpz9slnm0o0","created":1757594556530,"text":"消息分区：不受单台服务器的限制，可以不受限的处理更多的数据"},"children":[]},{"data":{"id":"dcpza2jh72g0","created":1757594578166,"text":"顺序读写：磁盘顺序读写，提高读写效率"},"children":[]},{"data":{"id":"dcpza8q56jc0","created":1757594591630,"text":"页缓存：把磁盘中的数据缓存到内存中，把对磁盘的访问转为对内存的访问"},"children":[]},{"data":{"id":"dcpzaid433k0","created":1757594612610,"text":"零拷贝：减少上下文切换及数据的拷贝"},"children":[]}]}]}]},{"data":{"id":"dd2hc473a8g0","created":1758864237957,"text":"ArrayList","expandState":"collapse"},"children":[{"data":{"id":"dd2hca8478o0","created":1758864251080,"text":"底层实现原理"},"children":[{"data":{"id":"dd2hcdnc7vs0","created":1758864258531,"text":"ArrayList底层是通过动态的数组实现的"},"children":[]},{"data":{"id":"dd2hcjgiyts0","created":1758864271180,"text":"ArrayList初始容量为0，当第一次添加数据的时候才会初始化容量为10"},"children":[]},{"data":{"id":"dd2hctwpiew0","created":1758864293926,"text":"ArrayList在进行扩容的时候是原来容量的1.5倍，每次扩容都需要拷贝数组"},"children":[]},{"data":{"id":"dd2hd9x6n1s0","created":1758864328783,"text":"ArrayList在添加数据的时候"},"children":[{"data":{"id":"dd2hdenr5og0","created":1758864339097,"text":"确保数组已使用长度（size）加1之后足够存下下一个数据"},"children":[]},{"data":{"id":"dd2hdugsko00","created":1758864373505,"text":"计算数组的容量，如果当前数组已使用长度+1后的大于当前的数组长度，则调用grow方法扩容（原来的1.5倍）"},"children":[]},{"data":{"id":"dd2heon89800","created":1758864439197,"text":"确保新增的数据有地方存储之后，则将新元素添加到位于size的位置上"},"children":[]},{"data":{"id":"dd2hf0sbokg0","created":1758864465627,"text":"返回添加成功布尔值"},"children":[]}]}]},{"data":{"id":"dd2hsjfo8i80","created":1758865524955,"text":"数组和List之间的转换"},"children":[{"data":{"id":"dd2hspbkee00","created":1758865537767,"text":"数组转List"},"children":[{"data":{"id":"dd2hsvb0dog0","created":1758865550794,"text":"使用asList方法"},"children":[{"data":{"id":"dd2ht2lrw680","created":1758865566683,"text":"修改数组的内容，list会受影响"},"children":[]}]}]},{"data":{"id":"dd2htfiqnio0","created":1758865594797,"text":"List转数组"},"children":[{"data":{"id":"dd2htincg0g0","created":1758865601606,"text":"使用toArray方法"},"children":[{"data":{"id":"dd2htm17y8o0","created":1758865608975,"text":"修改List的内容，数组不会受影响"},"children":[]}]}]}]},{"data":{"id":"dd2i1uvyofk0","created":1758866255164,"text":"链表"},"children":[{"data":{"id":"dd2i1wsj2sg0","created":1758866259308,"text":"单向链表和双向链表的区别"},"children":[{"data":{"id":"dd2i20ks7000","created":1758866267546,"text":"单向链表只有一个方向，结点只有一个后继指针next"},"children":[]},{"data":{"id":"dd2i29riemg0","created":1758866287544,"text":"双向链表支持两个方向，每个结点不止有一个后继节点next，还有一个前驱节点prev"},"children":[]}]},{"data":{"id":"dd2i2sjb8q80","created":1758866328407,"text":"时间复杂度"},"children":[{"data":{"id":"dd2i2vqprdc0","created":1758866335385,"text":"单向链表查询和新增删除头节点为O(1)，其他节点为O(n)"},"children":[]},{"data":{"id":"dd2i3srrsrs0","created":1758866407283,"text":"双向链表查询和新增删除头尾节点为O(1)，其他节点为O(n)，给定节点为O(1)"},"children":[]}]}]},{"data":{"id":"dd2i86xuna00","created":1758866751582,"text":"ArrayList和LinkedList的区别"},"children":[{"data":{"id":"dd2iajzu2yg0","created":1758866936729,"text":"底层数据结构"},"children":[{"data":{"id":"dd2iaocz5wo0","created":1758866946231,"text":"ArrayList是动态数组的数据结构"},"children":[]},{"data":{"id":"dd2iavop1lc0","created":1758866962177,"text":"LinkedList是双向链表的数据结构"},"children":[]}]},{"data":{"id":"dd2ib5p81c00","created":1758866983976,"text":"操作数据效率"},"children":[{"data":{"id":"dd2ibay0ukg0","created":1758866995392,"text":"ArrayList按照下标查询的时间复杂度为O(1)，LinkedList不支持下标查询"},"children":[]},{"data":{"id":"dd2ibw8h0000","created":1758867041737,"text":"ArrayList和LinkedList查询的时间复杂度都是O(n)"},"children":[]},{"data":{"id":"dd2ic7cc1nk0","created":1758867065915,"text":"ArrayList的新增和删除、LinkedList头尾增删时间复杂度都为O(1)"},"children":[]},{"data":{"id":"dd2id1hywo00","created":1758867131559,"text":"ArrayList和LinkedList其他部分增删时间复杂度都为O(n)"},"children":[]}]},{"data":{"id":"dd2ih3wbuqg0","created":1758867450237,"text":"内存空间占用"},"children":[{"data":{"id":"dd2ih7cza940","created":1758867457775,"text":"ArrayList底层是数组，内存连续，节省内存"},"children":[]},{"data":{"id":"dd2ihgt47u80","created":1758867478341,"text":"LinkedList是双向链表需要存储数据和两个指针，更占用内存"},"children":[]}]},{"data":{"id":"dd2ihwpyj1c0","created":1758867512979,"text":"线程安全"},"children":[{"data":{"id":"dd2ii65y75c0","created":1758867533537,"text":"ArrayList和LinkedList都不是线程安全的"},"children":[]},{"data":{"id":"dd2iid338wg0","created":1758867548601,"text":"解决方法"},"children":[{"data":{"id":"dd2iiekvkyo0","created":1758867551854,"text":"在方法内使用，局部变量则是线程安全的"},"children":[]},{"data":{"id":"dd2iikjehy00","created":1758867564825,"text":"使用线程安全的ArrayList和LinkedList，使用Collections.synchronizedList()方法"},"children":[]}]}]}]}]},{"data":{"id":"dd2kfjghjcw0","created":1758872969600,"text":"HashMap","expandState":"collapse"},"children":[{"data":{"id":"dd2kfmndc3s0","created":1758872976546,"text":"实现原理"},"children":[{"data":{"id":"dd2kfopm38w0","created":1758872981035,"text":"底层使用hash表数据结构，即数组+(链表|红黑树)"},"children":[]},{"data":{"id":"dd2kg2n2f940","created":1758873011356,"text":"添加数据时，计算key的值确定元素在数组中的下标"},"children":[{"data":{"id":"dd2kgd2a6g80","created":1758873034044,"text":"key相同则替换"},"children":[]},{"data":{"id":"dd2kgfubny00","created":1758873040093,"text":"key不同则存入链表或红黑树中"},"children":[]}]},{"data":{"id":"dd2kgzh5meo0","created":1758873082833,"text":"获取数据通过key的hash计算数组下标获取元素"},"children":[]}]},{"data":{"id":"dd2khm9wjqw0","created":1758873132460,"text":"jdk1.7和jdk1.8区别"},"children":[{"data":{"id":"dd2khsko2w80","created":1758873146172,"text":"jdk1.8之前采用拉链法，数组+链表"},"children":[]},{"data":{"id":"dd2khylv2tc0","created":1758873159305,"text":"jdk1.8之后采用数组+链表+红黑树，链表长度大于8且数组长度大于64则从链表转为红黑树"},"children":[]}]},{"data":{"id":"dd2l3pmbcvk0","created":1758874863753,"text":"put方法的具体流程"},"children":[{"data":{"id":"dd2l3tmgh200","created":1758874872468,"text":"1.判断键值对数组table是否为空或null，否则执行resize()进行扩容(初始化)"},"children":[]},{"data":{"id":"dd2l4wy00pc0","created":1758874958061,"text":"2.根据键值key计算hash值得到数组索引"},"children":[]},{"data":{"id":"dd2l5s13tmg0","created":1758875025729,"text":"3.判断table[i]==null，条件成立，直接新建节点添加"},"children":[]},{"data":{"id":"dd2l6pufozs0","created":1758875099336,"text":"4.如果table[I]==null，不成立"},"children":[{"data":{"id":"dd2l79yvtps0","created":1758875143141,"text":"1.判断table[i]的首个元素是否和key一样，如果相同直接覆盖value"},"children":[]},{"data":{"id":"dd2l8fm54uo0","created":1758875233795,"text":"2.判断table[i]是否为treeNode，即table[i]是否为红黑树，如果是红黑树，则直接在树中插入键值对"},"children":[]},{"data":{"id":"dd2l8ybglfc0","created":1758875274508,"text":"3.遍历table[i]，链表的尾部插入数据，然后判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，遍历过程中若发现key已经存在直接覆盖value"},"children":[]}]},{"data":{"id":"dd2lca33si80","created":1758875535217,"text":"5.插入成功后，判断实际存在的键值对数量size是否超过了最大容量threshold（数组长度*0.75），如果超过，进行扩容"},"children":[]}]},{"data":{"id":"dd2ls9qlqmo0","created":1758876788287,"text":"扩容机制"},"children":[{"data":{"id":"dd2lsbv2t8w0","created":1758876792912,"text":"在添加元素或初始化的时候要调用resize方法进行扩容，第一次添加数据初始化数组长度为16，以后每次扩容都达到扩容阈值（数组长度*0.75）"},"children":[]},{"data":{"id":"dd2lt18viu80","created":1758876848165,"text":"每次扩容的时候，都是扩容前的2倍"},"children":[]},{"data":{"id":"dd2lt7fq0lc0","created":1758876861640,"text":"扩容之后，会新建一个数组，需要把老数组中的数据挪动到新数组中"},"children":[]}]},{"data":{"id":"dd2m47bl5fs0","created":1758877723396,"text":"寻址算法"},"children":[{"data":{"id":"dd2m499fiyg0","created":1758877727619,"text":"计算对象的hashCode()"},"children":[]},{"data":{"id":"dd2m4d8a84w0","created":1758877736257,"text":"再进行调用hash()方法进行二次哈希，hashcode值右移16位再异或运算，让哈希分布更为均匀"},"children":[]},{"data":{"id":"dd2m50cnkkw0","created":1758877786587,"text":"最后（caoacity-1）& hash得到索引"},"children":[]}]}]},{"data":{"id":"dd51cvobe1c0","created":1759123839884,"text":"线程","expandState":"expand"},"children":[{"data":{"id":"dd54rptbrw80","created":1759133465918,"text":"线程基础","expandState":"collapse"},"children":[{"data":{"id":"dd51d0h3x280","created":1759123850332,"text":"线程与进程的区别","expandState":"expand"},"children":[{"data":{"id":"dd51d5eaceg0","created":1759123861045,"text":"进程是正在运行程序的实例，进程中包含线程，每个线程执行不同任务"},"children":[]},{"data":{"id":"dd51dgwg0ts0","created":1759123886088,"text":"不同进程使用不同空间，在当前线程下的所有线程可以共享内存空间"},"children":[]},{"data":{"id":"dd51dt1l25s0","created":1759123912520,"text":"线程更轻量，线程上下文切换成本一般要比进程上下文切换低（上下文切换指的是从一个线程切换到另外一个线程）"},"children":[]}]},{"data":{"id":"dd51d3uinio0","created":1759123857673,"text":"并发与并行的区别","expandState":"expand"},"children":[{"data":{"id":"dd51jdiul400","created":1759124348920,"text":"多核CPU下，并发是同一时间应对多件事情的能力，多个线程轮流使用一个或多个CPU"},"children":[]},{"data":{"id":"dd51jqk1v5s0","created":1759124377291,"text":"多核CPU下，并行是同一时间动手做多件事情的能力，4核CPU同时执行4个线程"},"children":[]}]},{"data":{"id":"dd51d3wn67s0","created":1759123857801,"text":"线程基础","expandState":"expand"},"children":[{"data":{"id":"dd51trdhel40","created":1759125162712,"text":"继承Thread类"},"children":[]},{"data":{"id":"dd51tvqcpe80","created":1759125172198,"text":"实现runnable接口"},"children":[]},{"data":{"id":"dd51tzcauso0","created":1759125180055,"text":"实现Callable接口"},"children":[]},{"data":{"id":"dd51u2owhig0","created":1759125187347,"text":"线程池创建线程"},"children":[]}]},{"data":{"id":"dd51xvpj6400","created":1759125485605,"text":"runnable和callable区别","expandState":"expand"},"children":[{"data":{"id":"dd51y2zwbow0","created":1759125501469,"text":"Runnable接口run方法没有返回值"},"children":[]},{"data":{"id":"dd51ya3h37c0","created":1759125516923,"text":"Callable接口call方法有返回值，需要FutureTask获取结果"},"children":[]},{"data":{"id":"dd51z29lerc0","created":1759125578243,"text":"Callable接口的call()方法允许抛出异常；而Runnable接口的run()方法异常只能内部消化，不能上抛"},"children":[]}]},{"data":{"id":"dd51zz1hym00","created":1759125649587,"text":"run()和start()区别","expandState":"expand"},"children":[{"data":{"id":"dd5204343t40","created":1759125660568,"text":"start():用来启动线程，通过该线程调用run方法执行run方法中所定义的逻辑代码。start方法只能被调用一次"},"children":[]},{"data":{"id":"dd520khhmso0","created":1759125696266,"text":"run():封装了要被线程执行的代码，可以被调用多次"},"children":[]}]},{"data":{"id":"dd52cgol40w0","created":1759126628358,"text":"线程的状态与变化","expandState":"expand"},"children":[{"data":{"id":"dd52cmj90680","created":1759126641096,"text":"状态"},"children":[{"data":{"id":"dd52csv51540","created":1759126654876,"text":"新建（NEW）"},"children":[]},{"data":{"id":"dd52cvz4zxk0","created":1759126661648,"text":"可运行（RUNNABLE）"},"children":[]},{"data":{"id":"dd52d296xfc0","created":1759126675316,"text":"阻塞（BLICKED）"},"children":[]},{"data":{"id":"dd52d5mm7xc0","created":1759126682659,"text":"等待（WAITING）"},"children":[]},{"data":{"id":"dd52db6lhqw0","created":1759126694751,"text":"时间等待（TIMED_WALTING）"},"children":[]},{"data":{"id":"dd52djnfdm00","created":1759126713182,"text":"终止（TERMINATED）"},"children":[]}]},{"data":{"id":"dd52gqnkzc80","created":1759126963522,"text":"变化"},"children":[{"data":{"id":"dd52gsavrmo0","created":1759126967107,"text":"创建线程对象是新建状态"},"children":[]},{"data":{"id":"dd52gwfekhs0","created":1759126976088,"text":"调用start()方法转变为可执行状态"},"children":[]},{"data":{"id":"dd52h20rf4g0","created":1759126988263,"text":"线程获取到CPU的执行权，执行结束是终止状态"},"children":[]},{"data":{"id":"dd52hbd1v1s0","created":1759127008598,"text":"在可执行状态的过程中，如果没有获取CPU的执行权，可能会切换到其他状态"},"children":[{"data":{"id":"dd52i3x7qew0","created":1759127070767,"text":"如果没有获取锁（synchronized或lock）进入阻塞状态，获得锁再切换为可执行状态"},"children":[]},{"data":{"id":"dd52iksoxrk0","created":1759127107498,"text":"如果线程调用wait()方法进入等待状态，其他线程调用notify()唤醒后可切换为可执行状态"},"children":[]},{"data":{"id":"dd52iyv4zb40","created":1759127138121,"text":"如果线程调用sleep(50)方法，进入计时等待状态，到时间切换为可执行状态"},"children":[]}]}]}]},{"data":{"id":"dd538lsncd40","created":1759129147141,"text":"如何保证T1、T2、T3三个线程按顺序执行"},"children":[{"data":{"id":"dd539hpw8k00","created":1759129216631,"text":"使用线程中的join方法解决"},"children":[{"data":{"id":"dd539nw9m8o0","created":1759129230077,"text":"join()-等待线程运行结束"},"children":[]}]}]},{"data":{"id":"dd53aqayks80","created":1759129313684,"text":"notify()和notifyAll()的区别"},"children":[{"data":{"id":"dd53ay9z82o0","created":1759129331038,"text":"notifyAll：唤醒所有wait的线程"},"children":[]},{"data":{"id":"dd53b42kluo0","created":1759129343651,"text":"notify：随机唤醒一个线程"},"children":[]}]},{"data":{"id":"dd547uvxf2w0","created":1759131909676,"text":"wait和sleep"},"children":[{"data":{"id":"dd548az94x40","created":1759131944706,"text":"共同点"},"children":[{"data":{"id":"dd548dngie80","created":1759131950523,"text":"wait(),wait(long)和sleep(long)的效果都是让当前线程暂时放弃CPU的使用权，进入阻塞状态"},"children":[]}]},{"data":{"id":"dd54ajlzxcg0","created":1759132120223,"text":"不同点"},"children":[{"data":{"id":"dd54alaqgqg0","created":1759132123896,"text":"1.方法归属不同"},"children":[{"data":{"id":"dd54anzwm9s0","created":1759132129772,"text":"sleep(long)是Thread的静态方法"},"children":[]},{"data":{"id":"dd54b6dughs0","created":1759132169796,"text":"wait(),wait(long)都是Object的成员方法，每个对象都有"},"children":[]}]},{"data":{"id":"dd54bnydl7k0","created":1759132208043,"text":"2.醒来时机不同"},"children":[{"data":{"id":"dd54btkcsbk0","created":1759132220256,"text":"执行sleep(long)和wait(long)的线程都会在等待对应毫秒之后醒来"},"children":[]},{"data":{"id":"dd54cg085eo0","created":1759132269105,"text":"wait(long)和wait()还可以被notify唤醒，wait()如果不唤醒就一直等下去"},"children":[]},{"data":{"id":"dd54czaa2mg0","created":1759132311072,"text":"它们都可以被打断唤醒"},"children":[]}]},{"data":{"id":"dd54d50owds0","created":1759132323553,"text":"3.锁特性不同"},"children":[{"data":{"id":"dd54ede56rc0","created":1759132420144,"text":"wait方法的调用必须先获取wait对象的锁，而sleep则不限制"},"children":[]},{"data":{"id":"dd54em17pqg0","created":1759132438954,"text":"wait方法执行后会释放对象锁，允许其他线程获得该对象锁（我放弃CPU，但你们还可以用）"},"children":[]},{"data":{"id":"dd54f4ox4000","created":1759132479569,"text":"而sleep如果在synchronized代码块中执行，并不会释放对象锁（我放弃CPU，你们也用不了，等我用完先）"},"children":[]}]}]}]},{"data":{"id":"dd54pb5kxko0","created":1759133277279,"text":"停止正在运行的线程","expandState":"expand"},"children":[{"data":{"id":"dd54ph9yh4o0","created":1759133290604,"text":"使用退出标志，使线程正常退出，也就是当run方法完成后线程终止"},"children":[]},{"data":{"id":"dd54puoqgdc0","created":1759133319796,"text":"使用stop方法强行停止"},"children":[]},{"data":{"id":"dd54pzklff40","created":1759133330430,"text":"使用interrupt方法中断线程"},"children":[{"data":{"id":"dd54q4l6fqo0","created":1759133341349,"text":"打断阻塞的线程（sleep，wait，join）的线程，线程会抛出InterruptedException异常"},"children":[]},{"data":{"id":"dd54qmibco00","created":1759133380358,"text":"打断正常的线程，可以根据打断状态来标记是否退出线程"},"children":[]}]}]}]},{"data":{"id":"ddegmhmjneg0","created":1760080949202,"text":"线程安全","expandState":"collapse"},"children":[{"data":{"id":"ddegmjy7zbc0","created":1760080954261,"text":"synchronized关键字的底层原理"},"children":[{"data":{"id":"ddegmqlrdoo0","created":1760080968745,"text":"synchronized【对象锁】采用互斥的方式让同一时刻至多只有一个线程能持有【对象锁】"},"children":[]},{"data":{"id":"ddegn6h8o200","created":1760081003301,"text":"底层由monitor实现，monitor是jvm级别的对象(c++实现)，线程获得锁需要使用对象（锁）关联monitor"},"children":[]},{"data":{"id":"ddegnuh35800","created":1760081055534,"text":"在monitor内部有三个属性，分别是owner、entrylist、waitest"},"children":[]},{"data":{"id":"ddego72ltpc0","created":1760081082957,"text":"其中owner是关联的获得锁的线程，并且只能关联一个线程；entrylist关联的是处于阻塞状态的线程；waitlist关联的是处于waiting状态的线程"},"children":[]}]},{"data":{"id":"ddeh6s52z740","created":1760082539374,"text":"锁升级"},"children":[{"data":{"id":"ddeh6xiex8g0","created":1760082551064,"text":"重量级锁"},"children":[{"data":{"id":"ddeh6zkj1r40","created":1760082555545,"text":"底层使用Monitor实现，里面涉及到用户态和内核态的切换、进程的上下文切换，成本较高，性能较低"},"children":[]}]},{"data":{"id":"ddeh7k3j2bk0","created":1760082600230,"text":"轻量级锁"},"children":[{"data":{"id":"ddeh9fs1wrc0","created":1760082747557,"text":"线程加锁的时间是错开的（也就是没有竞争），可以使用轻量级锁来优化。轻量级修改了对象头的锁标志，相对重量级锁性能提升很多。每次修改都是CAS操作，保证原子性"},"children":[]}]},{"data":{"id":"ddehax2v94g0","created":1760082863580,"text":"偏向锁"},"children":[{"data":{"id":"ddehb01criw0","created":1760082870019,"text":"一段很长的时间内都只被一个线程使用锁，可以使用偏向锁，在第一次获得锁时，会有一个CAS操作，之后该线程再获取锁，只需要判断mark word中是否是自己的线程id即可，而不是开销相对较大的CAS命令"},"children":[]}]},{"data":{"id":"ddehghmo8a00","created":1760083300134,"text":"一旦锁发生竞争，都会升级为重量级锁"},"children":[]}]},{"data":{"id":"ddehh77yrb40","created":1760083355841,"text":"JMM（Java内存模型）"},"children":[{"data":{"id":"ddehi6ia8dc0","created":1760083432653,"text":"JMM内存模型，定义了共享内存中多线程程序读写操作的行为规范，通过这些规则来规范对内存的读写操作从而保证指令的正确性"},"children":[]},{"data":{"id":"ddehjca86a80","created":1760083523590,"text":"JMM把内存分为两块，一块是私有线程的工作区域（工作内存），一块是所有线程的共享区域（主内存）"},"children":[]},{"data":{"id":"ddehjpenvfk0","created":1760083552157,"text":"线程跟线程之间是相互隔离，线程跟线程交互需要通过主内存"},"children":[]}]},{"data":{"id":"ddehrklpjqw0","created":1760084168612,"text":"CAS"},"children":[{"data":{"id":"ddehrmwpg0w0","created":1760084173631,"text":"CAS全称：Compare And Swap（比较再交换）：它体现的一种乐观锁的思想，在无锁状态下保证线程操作数据的原子性"},"children":[]},{"data":{"id":"ddehveowt3c0","created":1760084469202,"text":"CAS使用到的地方很多：AQS框架、AtomicXXX类"},"children":[]},{"data":{"id":"ddehwbi89340","created":1760084540632,"text":"在操作共享变量的时候使用自旋锁，效率上更高一些"},"children":[]},{"data":{"id":"ddehwmanezk0","created":1760084564118,"text":"CAS的底层调用的是Unsafe类中的方法，都是操作系统提供的，其他语言实现"},"children":[]}]},{"data":{"id":"ddehy3rd1so0","created":1760084680498,"text":"乐观锁和悲观锁的区别"},"children":[{"data":{"id":"ddei0bibl1c0","created":1760084854094,"text":"CAS是基于乐观锁的思想：最乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，我吃亏点再重试呗"},"children":[]},{"data":{"id":"ddei0r1ks8g0","created":1760084887910,"text":"synchronized是基于悲观锁的思想：最悲观的估计，得防着其他线程来修改共享变量，我上了锁你们都别想改，我改完了解开锁，你们才有机会"},"children":[]}]},{"data":{"id":"ddei8scyq8g0","created":1760085517689,"text":"volatile"},"children":[{"data":{"id":"ddei9bnyra00","created":1760085559713,"text":"保证线程间的可见性"},"children":[{"data":{"id":"ddei9nv61400","created":1760085586270,"text":"用volatile修饰共享变量，能防止编译器等优化发生，让一个线程对共享变量的修改对另一个线程可见"},"children":[]},{"data":{"id":"ddeia9irqa00","created":1760085633409,"text":"JVM虚拟机中有一个JIT（即时编译器）给代码做优化"},"children":[{"data":{"id":"ddeiajj6x5k0","created":1760085655202,"text":"在程序运行时加入vm参数-Xint表示禁用即时编译器，不推荐（其他程序还要用）"},"children":[]},{"data":{"id":"ddeib10rlqw0","created":1760085693270,"text":"在修饰变量的时候加上volatile，当前告诉jit，不要对volatile修饰的变量做优化"},"children":[]}]}]},{"data":{"id":"ddeik4l6sns0","created":1760086406313,"text":"禁止进行指令重排序"},"children":[{"data":{"id":"ddeik9m4j2o0","created":1760086417254,"text":"指令重排：用volatile修饰共享变量会在读、写共享变量时加入不同的屏障，阻止其他读写操作越过屏障，从而达到阻止重排序的效果"},"children":[]},{"data":{"id":"ddeikzyzuow0","created":1760086474628,"text":"使用技巧"},"children":[{"data":{"id":"ddeil37okio0","created":1760086481684,"text":"写变量让volatile修饰的变量的在代码最后位置"},"children":[]},{"data":{"id":"ddeilbbxsnk0","created":1760086499355,"text":"读变量让volatile修饰的变量的在代码最开始的位置"},"children":[]}]}]}]},{"data":{"id":"ddeiv3h60740","created":1760087265899,"text":"AQS"},"children":[{"data":{"id":"ddeiv5d7atc0","created":1760087270013,"text":"是多线程中的队列同步器。是一种锁机制，它是做为一个基础框架使用的，像ReenreantLock、Semaphore都是基于AQS实现的"},"children":[]},{"data":{"id":"ddeivzi0xrs0","created":1760087335608,"text":"AQS内部维护了一个先进先出的双向队列，队列中存储的排队的线程"},"children":[]},{"data":{"id":"ddeiwetyruo0","created":1760087368982,"text":"在AQS内部还有一个属性state，这个state就相当于是一个资源，默认是0（无锁状态），如果队列中的有一个线程修改成功了state为1，则当前线程相当于获取了资源"},"children":[]},{"data":{"id":"ddeix5znbxc0","created":1760087428098,"text":"在对state修改的时候使用cas操作，保证多个线程修改的情况下原子性"},"children":[{"data":{"id":"ddeixxq2f280","created":1760087488469,"text":"新线程与队列中的线程共同来抢资源，是非公平锁"},"children":[]},{"data":{"id":"ddeiy5cb4e80","created":1760087505051,"text":"新的线程到队列中等待，只让队列中的head线程获取锁，是公平锁"},"children":[]}]}]},{"data":{"id":"ddej6efobc00","created":1760088151759,"text":"ReentrantLock"},"children":[{"data":{"id":"ddej6jijx4g0","created":1760088162817,"text":"ReentrantLock表示支持重新进入的锁，调用lock方法获取锁之后，再次调用lock，是不会再阻塞"},"children":[]},{"data":{"id":"ddej71mqt400","created":1760088202253,"text":"ReentrantLock主要利用CAS+AQS队列来实现"},"children":[]},{"data":{"id":"ddej7hy8yjc0","created":1760088237777,"text":"支持公平锁和非公平锁，在提供的构造器中无参默认是非公平锁，也可以传参设置公平锁"},"children":[]}]},{"data":{"id":"ddekipr86sw0","created":1760091937882,"text":"synchronized和lock区别"},"children":[{"data":{"id":"ddekrepam340","created":1760092619098,"text":"语法"},"children":[{"data":{"id":"ddekrh5l6tc0","created":1760092624437,"text":"synchronized是关键字，源码在jvm中，用c++语言实现"},"children":[]},{"data":{"id":"ddekrrpyazk0","created":1760092647436,"text":"Lock是接口，源码由jdk提供，用java语言实现"},"children":[]},{"data":{"id":"ddekryxrxog0","created":1760092663147,"text":"使用synchronized时，退出同步代码块锁会自动释放，而使用Lock时，需要手动调用unlock方法释放锁"},"children":[]}]},{"data":{"id":"ddeksszg8l40","created":1760092728551,"text":"功能"},"children":[{"data":{"id":"ddekt1on5w80","created":1760092747489,"text":"二者均属于悲观锁、都具备基本的互斥、同步、锁重入功能"},"children":[]},{"data":{"id":"ddektbznl400","created":1760092769923,"text":"Lock提供了许多synchronized不具备的功能，例如公平锁、可打断、可超时、多条件变量"},"children":[]},{"data":{"id":"ddektpio3cw0","created":1760092799370,"text":"Lock有适应不同场景的实现，如ReentrantLock（读写锁）"},"children":[]}]},{"data":{"id":"ddekum0yk880","created":1760092870133,"text":"性能"},"children":[{"data":{"id":"ddekunc6iqo0","created":1760092872989,"text":"在没有竞争时，synchronized做了很多优化，如偏向锁、轻量级锁、性能不赖"},"children":[]},{"data":{"id":"ddekuzv98ww0","created":1760092900264,"text":"在竞争激烈时，Lock的实现通常会提供更好的性能"},"children":[]}]}]},{"data":{"id":"ddfa3cdbg8o0","created":1760164082138,"text":"死锁"},"children":[{"data":{"id":"ddfa3ejqnts0","created":1760164086880,"text":"死锁产生条件"},"children":[{"data":{"id":"ddfa3hjp6xs0","created":1760164093408,"text":"一个线程需要同时获取多把锁，容易产生死锁"},"children":[{"data":{"id":"ddfa474gvkw0","created":1760164149083,"text":"互斥条件"},"children":[]},{"data":{"id":"ddfa4gtruu00","created":1760164170204,"text":"不可剥夺条件"},"children":[]},{"data":{"id":"ddfa4kdoc880","created":1760164177938,"text":"请求与保持条件"},"children":[]},{"data":{"id":"ddfa4n4ktug0","created":1760164183918,"text":"循环等待条件"},"children":[]}]}]},{"data":{"id":"ddfa55xrdgg0","created":1760164224865,"text":"死锁诊断"},"children":[{"data":{"id":"ddfa581llfs0","created":1760164229451,"text":"当程序出现死锁，我们可以使用jdk自带工具"},"children":[{"data":{"id":"ddfa5hqdrns0","created":1760164250540,"text":"jps"},"children":[{"data":{"id":"ddfa5jetajk0","created":1760164254194,"text":"输出JVM中运行的进程状态信息"},"children":[{"data":{"id":"ddfa6oo6tug0","created":1760164344009,"text":"控制台输入jps"},"children":[]}]}]},{"data":{"id":"ddfa5q4cldc0","created":1760164268799,"text":"jstack"},"children":[{"data":{"id":"ddfa5rus9i00","created":1760164272574,"text":"查看java进程内线程的堆栈信息，查看日志，检查是否有死锁，如果有死锁现象，需要查看具体代码分析后，可修复"},"children":[{"data":{"id":"ddfa6rzy9w80","created":1760164351251,"text":"控制台输入jstack -l 死锁线程"},"children":[]}]}]},{"data":{"id":"ddfa6a126hk0","created":1760164312136,"text":"可视化工具jconsole、VisualVM"},"children":[]}]}]}]},{"data":{"id":"ddfa7xy10340","created":1760164442559,"text":"ConcurrentHashMap"},"children":[{"data":{"id":"ddfab9r1a9k0","created":1760164703350,"text":"数据结构"},"children":[{"data":{"id":"ddfabb9tr0w0","created":1760164706663,"text":"JDK1.7底层采用分段的数组+链表实现"},"children":[]},{"data":{"id":"ddfabjnwkdk0","created":1760164724929,"text":"JDK1.8采用的数据结构和HashMap1.8一样，数组+链表/红黑二叉树"},"children":[]}]},{"data":{"id":"ddfabxtiwcg0","created":1760164755744,"text":"加锁方式"},"children":[{"data":{"id":"ddfabzol6ts0","created":1760164759799,"text":"JDK1.7采用Segment分段锁，底层使用ReentrantLock"},"children":[]},{"data":{"id":"ddfacasfn7c0","created":1760164783976,"text":"JDK1.8采用CAS添加新节点，采用synchronized锁定链表或红黑二叉树的首节点，相对Segment分段锁粒度更细，性能更好"},"children":[]}]}]},{"data":{"id":"ddfahsu4xzc0","created":1760165215082,"text":"分支主题导致并发程序出现问题的根本原因"},"children":[{"data":{"id":"ddfahxc74eg0","created":1760165224881,"text":"原子性"},"children":[{"data":{"id":"ddfahytntm80","created":1760165228114,"text":"synchronized、lock"},"children":[]}]},{"data":{"id":"ddfaibhjv140","created":1760165255680,"text":"内存可见性"},"children":[{"data":{"id":"ddfaidvece00","created":1760165260871,"text":"volatile、synchronized、lock"},"children":[]}]},{"data":{"id":"ddfaiky17zc0","created":1760165276267,"text":"有序性"},"children":[{"data":{"id":"ddfaim6llm80","created":1760165278962,"text":"volatile"},"children":[]}]}]}]}]},{"data":{"id":"ddfatvrh0w80","created":1760166161821,"text":"JVM","expandState":"collapse"},"children":[{"data":{"id":"ddfau5jcr880","created":1760166183098,"text":"JVM组成","expandState":"expand"},"children":[{"data":{"id":"ddfatxjwixk0","created":1760166165717,"text":"程序计数器"},"children":[{"data":{"id":"ddfaua4s9i80","created":1760166193101,"text":"线程私有的，每个线程一份，内部保存的字节码的行号。用于记录正在执行的字节码指令的地址。"},"children":[]}]}]},{"data":{"id":"ddfayo9bgf40","created":1760166537307,"text":"Java堆","expandState":"expand"},"children":[{"data":{"id":"ddfayvnids00","created":1760166553402,"text":"主要用于保存对象实例、数组等，内存不够则抛出OutOfMemoryError异常"},"children":[]},{"data":{"id":"ddfazevixk00","created":1760166595246,"text":"年轻代+老年代"},"children":[{"data":{"id":"ddfazi1j9080","created":1760166602140,"text":"年轻代被划分为三部分，Eden区和两个大小严格相同的Survivor（幸存者）区"},"children":[]},{"data":{"id":"ddfazxadx0o0","created":1760166635326,"text":"老年代主要保存生命周期长的对象，一般是一些老的对象"},"children":[]}]},{"data":{"id":"ddfb07518ds0","created":1760166656771,"text":"jdk1.7和jdk1.8"},"children":[{"data":{"id":"ddfb0c3hm1k0","created":1760166667561,"text":"jdk1.7中有一个永久代，存储的是类信息、静态变量、常量、编译后的代码"},"children":[]},{"data":{"id":"ddfb0qz5k600","created":1760166699951,"text":"jdk1.8移除永久代，把数据存储到本地内存的元空间中，防止内存溢出"},"children":[]}]}]},{"data":{"id":"ddfb6ulximo0","created":1760167178043,"text":"虚拟机栈","expandState":"expand"},"children":[{"data":{"id":"ddfb6xh1kiw0","created":1760167184278,"text":"什么是虚拟机栈"},"children":[{"data":{"id":"ddfb70p1y080","created":1760167191293,"text":"每个线程运行时所需要的内存"},"children":[]},{"data":{"id":"ddfb769d1io0","created":1760167203405,"text":"每个栈由多个栈帧组成，对应每次方法调用时所占用的内存"},"children":[]},{"data":{"id":"ddfb7p59k2w0","created":1760167244516,"text":"每个线程只能有一个活动栈帧，对应当前正在执行的方法"},"children":[]}]},{"data":{"id":"ddfb7ytow5k0","created":1760167265584,"text":"垃圾回收是否涉及栈内存"},"children":[{"data":{"id":"ddfb8396bjc0","created":1760167275227,"text":"垃圾回收主要指堆内存，当栈帧弹栈以后，内存就会释放"},"children":[]}]},{"data":{"id":"ddfb8d1hp600","created":1760167296530,"text":"栈内存分配越大越好吗"},"children":[{"data":{"id":"ddfb8isc9oo0","created":1760167309038,"text":"默认栈内存为1024k，栈帧过大会导致线程数变少"},"children":[]}]},{"data":{"id":"ddfb8rx6owg0","created":1760167328922,"text":"方法内的局部变量是否线程安全"},"children":[{"data":{"id":"ddfb8y8rr3s0","created":1760167342683,"text":"如果方法内局部变量没有逃离方法的作用范围，它是线程安全的"},"children":[]},{"data":{"id":"ddfb988z2jk0","created":1760167364463,"text":"如果局部变量引用了对象，并逃离方法的作用范围，需要考虑线程安全"},"children":[]}]},{"data":{"id":"ddfb9ii99w80","created":1760167386792,"text":"导致栈内存溢出"},"children":[{"data":{"id":"ddfba1nptts0","created":1760167428481,"text":"栈帧过多导致栈内存溢出，典型问题：递归调用"},"children":[]},{"data":{"id":"ddfbafln9ko0","created":1760167458831,"text":"栈帧过大导致栈内存溢出"},"children":[]}]},{"data":{"id":"ddfbb1kxakw0","created":1760167506677,"text":"堆栈区别"},"children":[{"data":{"id":"ddfbb4b4pzc0","created":1760167512615,"text":"栈内存一般用来存储局部变量和方法调用，堆内存用来存储Java对象和数组的。堆会GC垃圾回收，而栈不会 "},"children":[]},{"data":{"id":"ddfbby29dcw0","created":1760167577382,"text":"栈内存是线程私有的，堆内存是线程共有的"},"children":[]},{"data":{"id":"ddfbc5it56w0","created":1760167593620,"text":"两个异常错误不同，栈内存和堆内存不足都会抛出异常"},"children":[{"data":{"id":"ddfbcjdqg3k0","created":1760167623788,"text":"栈空间不足：java.lang.StackOverFlowError"},"children":[]},{"data":{"id":"ddfbctep6ug0","created":1760167645614,"text":"堆空间不足：java.long.OutOfMemoryError"},"children":[]}]}]}]},{"data":{"id":"ddfcdriafww0","created":1760170540952,"text":"方法区","expandState":"expand"},"children":[{"data":{"id":"ddfcdzl0z7k0","created":1760170558532,"text":"方法区是各个线程共享的内存区域"},"children":[]},{"data":{"id":"ddfce4hrq7c0","created":1760170569219,"text":"主要存储类的信息、运行时常量池"},"children":[]},{"data":{"id":"ddfce9f6n340","created":1760170579946,"text":"虚拟机启动的时候创建，关闭虚拟机时释放"},"children":[]},{"data":{"id":"ddfcef2sr0g0","created":1760170592258,"text":"如果方法区域中的内存无法满足分配请求，则抛出OutOfMemoryError:Metaspace"},"children":[]}]},{"data":{"id":"ddfceyuhqbs0","created":1760170635291,"text":"运行时常量池","expandState":"expand"},"children":[{"data":{"id":"ddfcf133bc80","created":1760170640165,"text":"常量池：可以看作一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等信息"},"children":[]},{"data":{"id":"ddfcfejr9zk0","created":1760170669471,"text":"当类被加载，它的常量池信息会放入运行时常量池，并把里面的符号地址变为真实地址"},"children":[]}]},{"data":{"id":"ddfckl3avmg0","created":1760171075534,"text":"直接内存","expandState":"expand"},"children":[{"data":{"id":"ddfckmce49s0","created":1760171078261,"text":"并不属于JVM中的内存结构，不由JVM管理。是虚拟机的系统内存"},"children":[]},{"data":{"id":"ddfckv7ftqg0","created":1760171097552,"text":"常见于NIO操作，用于数据缓冲区，分配回收成本较高，但读写性能高，不受JVM内存回收管理"},"children":[]}]},{"data":{"id":"ddfcna4w1bk0","created":1760171286778,"text":"类加载器","expandState":"expand"},"children":[{"data":{"id":"ddfcnekjpjc0","created":1760171296432,"text":"JVM只会运行二进制文件，类加载器的作用是将字节码文件加载到JVM中，从而让Java程序能够启动起来"},"children":[{"data":{"id":"ddfcnwwafrk0","created":1760171336324,"text":"启动类加载器：加载JAVA_HOME/jre/lib目录下的库"},"children":[]},{"data":{"id":"ddfco81u6rs0","created":1760171360604,"text":"扩展类加载器：加载JAVA_HOME/jre/lib/ext目录中的类"},"children":[]},{"data":{"id":"ddfcohsb2ew0","created":1760171381796,"text":"应用类加载器：用于加载classPath下的类"},"children":[]},{"data":{"id":"ddfcoo69bxs0","created":1760171395700,"text":"自定义类加载器：自定义类继承ClassLoader，实现自定义类加载规则"},"children":[]}]},{"data":{"id":"ddfcslc687c0","created":1760171702984,"text":"双亲委派模型"},"children":[{"data":{"id":"ddfcsoo8t9c0","created":1760171710244,"text":"加载某一个类，先委托上一级的加载器进行加载，如果上级加载器也有上级，则会继续向上委托，如果该类委托上级没有被加载，子加载器尝试加载该类"},"children":[]},{"data":{"id":"ddfctsih4680","created":1760171796967,"text":"通过双亲委派机制可以避免某一个类被重复加载，当父类已经加载后则无需重复加载，保证唯一性"},"children":[]},{"data":{"id":"ddfcu4v1fu80","created":1760171823848,"text":"为了安全，保证类库API不会被修改"},"children":[]}]}]},{"data":{"id":"dee449d21eo0","created":1763701825780,"text":"垃圾回收","expandState":"collapse"},"children":[{"data":{"id":"dee44ihnvyg0","created":1763701845650,"text":"如果一个或多个对象没有任何的引用指向它，那这个对象就是垃圾，如果定位了垃圾，就有可能会被垃圾回收器回收"},"children":[]},{"data":{"id":"dee4575rduo0","created":1763701899349,"text":"定位垃圾","expandState":"expand"},"children":[{"data":{"id":"dee450w1d880","created":1763701885701,"text":"引用计数法"},"children":[{"data":{"id":"dee45qqfyao0","created":1763701941959,"text":"一个对象被引用了一次，就在当前对象头上递增一个引用次数，如果这个对象的引用次数为0，代表可回收"},"children":[]}]},{"data":{"id":"dee454dkzls0","created":1763701893292,"text":"可达性分析算法"},"children":[{"data":{"id":"dee46akxfts0","created":1763701985161,"text":"扫描堆中的对象，看是否能够沿着GC Root对象为起点的引用链找到该对象，找不到表示可以回收"},"children":[]},{"data":{"id":"dee46tgu4qw0","created":1763702026273,"text":"GC Root"},"children":[{"data":{"id":"dee46vn93480","created":1763702031014,"text":"虚拟机栈中引用的对象"},"children":[]},{"data":{"id":"dee470j7dio0","created":1763702041653,"text":"方法区中类静态属性引用的对象"},"children":[]},{"data":{"id":"dee476pb56w0","created":1763702055083,"text":"方法区中常量引用的对象"},"children":[]},{"data":{"id":"dee47bn6nzs0","created":1763702065840,"text":"本地方法栈中JNI（即一般说的是Native方法）引用的对象"},"children":[]}]}]}]},{"data":{"id":"dee4aczpupc0","created":1763702303866,"text":"垃圾回收算法"},"children":[{"data":{"id":"dee4ag6bcm80","created":1763702310795,"text":"标记清除算法"},"children":[{"data":{"id":"dee4ak3q7480","created":1763702319346,"text":"垃圾回收分为2个阶段，标记和清除"},"children":[]},{"data":{"id":"dee4axx2vr40","created":1763702349419,"text":"优点：效率高"},"children":[]},{"data":{"id":"dee4b1pj5gw0","created":1763702357669,"text":"缺点：有磁盘碎片，内存不连续"},"children":[]}]},{"data":{"id":"dee4bu7qjsg0","created":1763702419720,"text":"标记整理算法"},"children":[{"data":{"id":"dee4bwt2nl40","created":1763702425364,"text":"和标记清除算法一样，将存活对象都向内存另一端移动，然后清除边界以外的垃圾"},"children":[]},{"data":{"id":"dee4cios77c0","created":1763702472993,"text":"优点：无碎片"},"children":[]},{"data":{"id":"dee4cm923fs0","created":1763702480750,"text":"缺点：对象需要移动，效率低"},"children":[]}]},{"data":{"id":"dee4d3f8ljs0","created":1763702518129,"text":"复制算法"},"children":[{"data":{"id":"dee4d55j9000","created":1763702521896,"text":"将原有的内存碎片一分为二，每次只用其中的一块，正在使用的对象复制到另一个内存空间中，然后将该内存空间清空，交换两个内存的角色"},"children":[]},{"data":{"id":"dee4dsrgbls0","created":1763702573287,"text":"优点：无碎片"},"children":[]},{"data":{"id":"dee4dw9blsg0","created":1763702580898,"text":"缺点：内存使用率低"},"children":[]}]}]},{"data":{"id":"dee5ik0oiw00","created":1763705767185,"text":"分代回收"},"children":[{"data":{"id":"dee5itd9wog0","created":1763705787537,"text":"堆的区域划分"},"children":[{"data":{"id":"dee5iy9iwrs0","created":1763705798194,"text":"堆被分成两份：新生代和老年代【1：2】"},"children":[]},{"data":{"id":"dee5j4gwbts0","created":1763705811701,"text":"对于新生代，内部又被划分为三个区域：Eden区，幸存者区survivor（分为from和to）【8：1：1】"},"children":[]}]},{"data":{"id":"dee5jt6j7y00","created":1763705865494,"text":"对象回收分代回收策略"},"children":[{"data":{"id":"dee5k08pz7k0","created":1763705880863,"text":"新创建的对象，都会优先分配到eden区"},"children":[]},{"data":{"id":"dee5k6y9cds0","created":1763705895468,"text":"当eden区内存不足，标记eden区和from区的存活对象"},"children":[]},{"data":{"id":"dee5khlyz7k0","created":1763705918670,"text":"将存活对象采用复制算法复制到to区中，复制完毕后，eden区和from区内存得到释放"},"children":[]},{"data":{"id":"dee5kr9fxjs0","created":1763705939680,"text":"经过一段时间eden区内存出现不足，标记eden区和to区存货的对象，复制到from区中"},"children":[]},{"data":{"id":"dee5l942jow0","created":1763705978537,"text":"当新村这区对象熬过几次回收（最多15次），晋升到老年代（幸存者区内存不足或大对象会提前晋升）"},"children":[]}]}]},{"data":{"id":"dee5m6u62vk0","created":1763706051949,"text":"MinorGC、MixedGC、FullGC"},"children":[{"data":{"id":"dee5orqdq5c0","created":1763706254161,"text":"STW：暂停所有应用程序线程，等待垃圾回收完成"},"children":[]},{"data":{"id":"dee5muuovkw0","created":1763706104224,"text":"MinorGC：【youngGC】发生在新生代的垃圾回收，暂停时间短(STW)"},"children":[]},{"data":{"id":"dee5nj9y5yo0","created":1763706157389,"text":"MixedGC：新生代+老年代部分区域的垃圾回收，G1收集器特有"},"children":[]},{"data":{"id":"dee5o67q4dc0","created":1763706207321,"text":"FullGC：新生代+老年代完整垃圾回收，暂停时间长（STW），应尽力避免"},"children":[]}]},{"data":{"id":"dee5q2djx0g0","created":1763706355694,"text":"垃圾回收器"},"children":[{"data":{"id":"dee5tpnvwuw0","created":1763706641477,"text":"串行垃圾收集器"},"children":[{"data":{"id":"dee5u3wt6go0","created":1763706672492,"text":"使用单线程进行垃圾回收，堆内存较小，适合个人电脑"},"children":[]},{"data":{"id":"dee5tv2hvts0","created":1763706653245,"text":"Serial作用于新生代，采用复制算法"},"children":[]},{"data":{"id":"dee5ufarvhc0","created":1763706697281,"text":"Serial Old作用于老年代，采用标记-整理算法"},"children":[]},{"data":{"id":"dee5uo20db40","created":1763706716342,"text":"垃圾回收时，只有一个线程工作，并且java应用中所有线程都要暂停(STW)，等待垃圾回收完成"},"children":[]}]},{"data":{"id":"dee5vf593wo0","created":1763706775311,"text":"并行垃圾收集器"},"children":[{"data":{"id":"dee5viw8no00","created":1763706783473,"text":"JDK8默认使用此垃圾回收器"},"children":[]},{"data":{"id":"dee5vtug1og0","created":1763706807309,"text":"Paralled New作用于新生代，采用复制算法"},"children":[]},{"data":{"id":"dee5w3l7j9k0","created":1763706828519,"text":"Paralled Old作用于老年代，采用标记-整理算法"},"children":[]},{"data":{"id":"dee5wegt46g0","created":1763706852197,"text":"垃圾回收时，只有一个线程工作，并且java应用中所有线程都要暂停(STW)，等待垃圾回收完成"},"children":[]}]},{"data":{"id":"dee5wvmwut40","created":1763706889572,"text":"CMS（并发）垃圾收集器"},"children":[{"data":{"id":"dee5xddgt7k0","created":1763706928183,"text":"是一款并发的，使用标记-清除算法的垃圾回收器，该回收器是针对老年代垃圾回收的"},"children":[]},{"data":{"id":"dee5yn68tdc0","created":1763707027878,"text":"是一款以获取最短回收停顿时间为目标的收集器，停顿时间短，用户体验好。最大特点是进行垃圾回收时，应用仍然能正常运行"},"children":[]}]},{"data":{"id":"dee5yv6dnfc0","created":1763707045300,"text":"G1垃圾收集器"},"children":[{"data":{"id":"dee5z13tqu80","created":1763707058207,"text":"应用于新生代和老年代，在JDK9之后默认使用G1垃圾收集器"},"children":[]},{"data":{"id":"dee69s7ei540","created":1763707900838,"text":"划分为多个区域，每个区域都可以充当eden，survivor，old，humongous，其中humongous专为大对象准备"},"children":[]},{"data":{"id":"dee6anf29iw0","created":1763707968781,"text":"采用复制算法"},"children":[]},{"data":{"id":"dee6auq7x6o0","created":1763707984693,"text":"响应时间与吞吐量兼顾高效"},"children":[]},{"data":{"id":"dee6b80b3680","created":1763708013601,"text":"分为三个阶段：新生代回收（stw）、并发标记（重新标记stw）、混合收集"},"children":[]},{"data":{"id":"dee6c32p26o0","created":1763708081226,"text":"如果并发失败，会出发Full GC "},"children":[]}]},{"data":{"id":"dee6hxiy2800","created":1763708539333,"text":"引用"},"children":[{"data":{"id":"dee6i0lx5eg0","created":1763708546043,"text":"强引用：只要所有GC Roots能找到，就不会被回收"},"children":[]},{"data":{"id":"dee6iwzyqnc0","created":1763708616550,"text":"软引用：需要配合SoftReference使用，当垃圾多次回收，内存依然不够会回收引用对象"},"children":[]},{"data":{"id":"dee6jay6of40","created":1763708646917,"text":"弱引用：需要配合WeakReference使用，只要进行垃圾回收，就会吧弱引用对象回收"},"children":[]},{"data":{"id":"dee6jnsxbmo0","created":1763708674897,"text":"虚引用：必须配合引用队列使用，被引用对象回收时，会将虚引用入队，由Reference Handler线程调用虚引用相关方法释放直接内存"},"children":[]}]}]},{"data":{"id":"deftu9px8jc0","created":1763875951731,"text":"JVM调优参数"},"children":[{"data":{"id":"defuhbr05e00","created":1763877758525,"text":"设置参数值","expandState":"expand"},"children":[{"data":{"id":"deftuewxn0w0","created":1763875963038,"text":"war包部署在tomcat中设置"},"children":[{"data":{"id":"deftumjlyns0","created":1763875979647,"text":"修改TOMACAT_HOME/bin/catalina.sh文件"},"children":[]}]},{"data":{"id":"deftuwlra800","created":1763876001545,"text":"jar包部署在启动参数设置"},"children":[{"data":{"id":"deftv6h38jk0","created":1763876023030,"text":"java -Xms512m -Xmx1024m -jar xxxx.jar"},"children":[]}]}]},{"data":{"id":"defuhx72v8g0","created":1763877805210,"text":"设置堆空间大小"},"children":[{"data":{"id":"defui1kvf600","created":1763877814751,"text":"-Xms：设置堆的初始化大小"},"children":[]},{"data":{"id":"defuif5apfk0","created":1763877844284,"text":"-Xmx：设置堆的最大大小"},"children":[]},{"data":{"id":"defujqc6g080","created":1763877947009,"text":"为了避免堆收缩，通常把最大、初始大小设置为相同的值"},"children":[]},{"data":{"id":"defukdln5eg0","created":1763877997647,"text":"最大大小的默认值是物理内存的1/4，初始大小是物理内存的1/64"},"children":[]},{"data":{"id":"defukt0y5qo0","created":1763878031224,"text":"堆太小，可能会频繁导致年轻代和老年代的垃圾回收，产生stw，暂停用户线程"},"children":[]},{"data":{"id":"deful4nod600","created":1763878056543,"text":"堆内存大，存在风险，假如发生fullgc，扫描整个堆空间，暂停用户线程的时间长"},"children":[]}]},{"data":{"id":"defumamstko0","created":1763878147915,"text":"虚拟机栈的设置"},"children":[{"data":{"id":"defumlfzh600","created":1763878171448,"text":"每个线程默认开启1M内存，但一般256k够用"},"children":[]},{"data":{"id":"defumwbpee00","created":1763878195134,"text":"-Xss 对每个线程stack大小的调整，-Xss128k"},"children":[]}]},{"data":{"id":"defunfxe76g0","created":1763878237804,"text":"年轻代中Eden区和两个Survivor区的大小比例","expandState":"expand"},"children":[{"data":{"id":"defuo0jy8uw0","created":1763878282703,"text":"Eden区和两个Survivor区默认为8：1：1"},"children":[]},{"data":{"id":"defuoth9w280","created":1763878345668,"text":"-XXSurvivorRatio=8，表示年轻代中的分配比率：survivor：eden=2：8"},"children":[]}]},{"data":{"id":"defuol6fnqw0","created":1763878327599,"text":"年轻代晋升老年代阈值","expandState":"expand"},"children":[{"data":{"id":"defupbthehc0","created":1763878385589,"text":"-XX:MaxTenuringThreshold=threshold"},"children":[]},{"data":{"id":"defupo0e3hs0","created":1763878412128,"text":"默认15，取值范围0-15"},"children":[]}]},{"data":{"id":"defuq1n0s7k0","created":1763878441794,"text":"设置垃圾回收器"},"children":[{"data":{"id":"defuq8jwcgo0","created":1763878456843,"text":"设置G1垃圾回收器"},"children":[{"data":{"id":"defuqctabx40","created":1763878466118,"text":"-XX:UseG1GC"},"children":[]}]}]}]},{"data":{"id":"defuw0m4za00","created":1763878909749,"text":"JVM调优工具","expandState":"expand"},"children":[{"data":{"id":"defv8wyy5s00","created":1763879920551,"text":"pid：进程状态编号"},"children":[]},{"data":{"id":"defuxg9cg2w0","created":1763879022168,"text":"jps：进程状态信息"},"children":[]},{"data":{"id":"defuxr709js0","created":1763879045971,"text":"jstack：查看java进程内线程的堆栈信息"},"children":[]},{"data":{"id":"defv1m64fww0","created":1763879348491,"text":"jmap：用于生成堆转内存快照、内存使用情况"},"children":[{"data":{"id":"defv393juqg0","created":1763879476765,"text":"jmap -heap pid 显示Java堆的信息"},"children":[]},{"data":{"id":"defv3q8qv9c0","created":1763879514085,"text":"jmap -dump:format=b,file=heap.hprof pid"},"children":[{"data":{"id":"defv4ccloio0","created":1763879562207,"text":"format=b表示以hprof二进制格式转储Java堆的内存"},"children":[]},{"data":{"id":"defv58wn5hk0","created":1763879633076,"text":"file=<filename>用于指定快照dump文件的文件名"},"children":[]}]}]},{"data":{"id":"defv7hlx8ww0","created":1763879808747,"text":"jstat：JVM统计监测工具"},"children":[{"data":{"id":"defv7w4qshc0","created":1763879840360,"text":"jstat -gcutil pid"},"children":[{"data":{"id":"defv8329agg0","created":1763879855447,"text":"总结垃圾回收统计"},"children":[]}]},{"data":{"id":"defv8b5zok00","created":1763879873087,"text":"jstat -gc pid"},"children":[{"data":{"id":"defv8hg2z740","created":1763879886758,"text":"垃圾回收统计"},"children":[]}]}]},{"data":{"id":"defv9izgx7k0","created":1763879968471,"text":"可视化工具"},"children":[{"data":{"id":"defv9levepc0","created":1763879973756,"text":"jconsole"},"children":[{"data":{"id":"defv9w3s6rk0","created":1763879997030,"text":"用于对jvm的内存，线程，类的监控，是一个基于jmx的GUI性能监控工具"},"children":[]},{"data":{"id":"defvahctq1k0","created":1763880043289,"text":"java安装目录bin目录下直接启动jconsole.exe"},"children":[]}]},{"data":{"id":"defvb3yet600","created":1763880092484,"text":"VisualVM"},"children":[{"data":{"id":"defvbbzw8oo0","created":1763880109988,"text":"能够监控线程，内存情况，查看方法的CPU时间和内存中的对象，已被GC的对象，反向查看分配的堆栈"},"children":[]},{"data":{"id":"defvbywvka00","created":1763880159871,"text":"java安装目录bin目录下直接启动jvisualvm.exe就行"},"children":[]}]}]}]},{"data":{"id":"deiewz87f540","created":1764138527205,"text":"JVM内存泄露排查与思路"},"children":[{"data":{"id":"deiff1qcbxk0","created":1764139943211,"text":"内存泄露通常指的是堆内存，指一些大对象不被回收的情况"},"children":[]},{"data":{"id":"deiffrgecsw0","created":1764139999206,"text":"1、通过jmap或者设置jvm参数获取堆内存快照dump"},"children":[{"data":{"id":"deiflop60680","created":1764140463390,"text":"jmap"},"children":[{"data":{"id":"deifl5a69140","created":1764140421125,"text":"jmap -dump:format=b,file=heap.hprof pid"},"children":[]}]},{"data":{"id":"deiflgf62h40","created":1764140445372,"text":"jvm"},"children":[{"data":{"id":"deiflmx0mfs0","created":1764140459512,"text":"-XX:+HeapDumpOnOutOfMemoryError             -XX:HeapDumpPath=/home/app/dumps/"},"children":[]}]}]},{"data":{"id":"deifg21zv1s0","created":1764140022279,"text":"2、通过工具VisualVM去分析dump文件，VisualVM可以加载离线的dump文件"},"children":[]},{"data":{"id":"deifie7jf2o0","created":1764140205464,"text":"3、通过查看堆信息的情况，可以大概定位内存溢出是哪行代码出了问题"},"children":[]},{"data":{"id":"deifip2m3940","created":1764140229111,"text":"4、找到对应的代码，通过阅读上下文的情况，进行修复即可"},"children":[]}]},{"data":{"id":"deifp5uwldc0","created":1764140735835,"text":"CPU飙高排查与思路"},"children":[{"data":{"id":"deifzypybo80","created":1764141582304,"text":"1、通过top命令查看占用cpu的情况"},"children":[{"data":{"id":"deig2rytfnc0","created":1764141802695,"text":"打开finalshell 输入top"},"children":[]}]},{"data":{"id":"deig0ya5nqg0","created":1764141659713,"text":"2、通过top命令查看后，可以查看是哪一个进程占用cpu较高"},"children":[]},{"data":{"id":"deig27esjww0","created":1764141757949,"text":"3、使用ps命令查看进程中的线程信息"},"children":[{"data":{"id":"deig4gv87sw0","created":1764141935262,"text":"ps H -eo pid，tid，%cpu | grep 40940  （此处是进程id）"},"children":[]}]},{"data":{"id":"deig2bw4hnk0","created":1764141767704,"text":"4、使用jstack命令查看进程中哪些线程出了问题，最终定位问题"},"children":[{"data":{"id":"deig6qa50ao0","created":1764142112483,"text":"jstack 40940 （此处是进程id）"},"children":[]},{"data":{"id":"deig77sumog0","created":1764142150620,"text":"将线程id转换为十六进制"},"children":[{"data":{"id":"deig7fls5sg0","created":1764142167606,"text":"printf “%x” 40955  （此处是线程id）"},"children":[]}]},{"data":{"id":"deigb8h817k0","created":1764142465550,"text":"查看代码","expandState":"expand"},"children":[{"data":{"id":"deiga3u0xcw0","created":1764142377076,"text":"ls（查看正在进行的文件名称）"},"children":[]},{"data":{"id":"deigaxvnrbk0","created":1764142442478,"text":"cat 需要查看的文件"},"children":[]}]}]}]}]}]},{"data":{"id":"ddfd2k9ii7k0","created":1760172484288,"text":"设计模式","expandState":"collapse"},"children":[{"data":{"id":"ddfd2mezovc0","created":1760172488973,"text":"工厂设计模式"},"children":[{"data":{"id":"ddfd2pxsv8w0","created":1760172496640,"text":"简单工厂模式"},"children":[{"data":{"id":"ddfd87kqqrc0","created":1760172926854,"text":"所有产品共用一个工厂，如果新增产品，则需要修改代码，违反开闭原则"},"children":[]},{"data":{"id":"ddfd8ghdwi00","created":1760172946242,"text":"是一种编程习惯，可以借鉴这种编程思路"},"children":[]}]},{"data":{"id":"ddfd2zzqxbc0","created":1760172518526,"text":"工厂方法模式"},"children":[{"data":{"id":"ddfd40e0twg0","created":1760172597753,"text":"优点","expandState":"expand"},"children":[{"data":{"id":"ddfd376el740","created":1760172534166,"text":"用户只需要知道具体工厂名称就可得到所要的产品，无须知道产品的具体创建过程"},"children":[]},{"data":{"id":"ddfd3ku2qxs0","created":1760172563895,"text":"在系统增加新产品时只要添加具体产品类和对应的具体工厂类，无须堆原工厂进行修改，满足开闭原则"},"children":[]}]},{"data":{"id":"ddfd439d3gg0","created":1760172604002,"text":"缺点"},"children":[{"data":{"id":"ddfd44babbk0","created":1760172606295,"text":"每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类，增加系统复杂度"},"children":[]}]}]},{"data":{"id":"ddfd8qmilk00","created":1760172968320,"text":"抽象工厂模式"},"children":[{"data":{"id":"ddfd99gwxo80","created":1760173009340,"text":"抽象工厂模式可以生产多个等级的产品"},"children":[{"data":{"id":"ddfd9lno8js0","created":1760173035870,"text":"是一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂"},"children":[]}]}]}]},{"data":{"id":"ddfdgo2dgts0","created":1760173589662,"text":"策略模式"},"children":[{"data":{"id":"ddfdgxr4rk80","created":1760173610750,"text":"该模式定义了一系列算法，把每个算法封装起来，使他们可以相互替换。且算法的变化不会影响使用算法的客户"},"children":[]},{"data":{"id":"ddfdhd230dk0","created":1760173644064,"text":"通过对算法进行封装，并把使用算法的责任和算法的实现分割，并委派给不同的对象对这些算法进行管理"},"children":[]},{"data":{"id":"ddfdhwi74dk0","created":1760173686397,"text":"优点"},"children":[{"data":{"id":"ddfdhxju40o0","created":1760173688673,"text":"策略类之间可以相互转换"},"children":[]},{"data":{"id":"ddfdi2potsg0","created":1760173699910,"text":"易于扩展"},"children":[]},{"data":{"id":"ddfdi56krk80","created":1760173705285,"text":"避免使用多重条件选择语句（if-else），充分体现面向对象设计思想"},"children":[]}]},{"data":{"id":"ddfdinao34w0","created":1760173744715,"text":"缺点"},"children":[{"data":{"id":"ddfdiuag2y80","created":1760173759939,"text":"客户端必须知道所有的策略类，并自行决定使用哪一个策略类"},"children":[]},{"data":{"id":"ddfdj5ly89c0","created":1760173784579,"text":"策略模式将造成产生很多策略类"},"children":[]}]}]},{"data":{"id":"ddfdtvlo8u00","created":1760174624800,"text":"责任链模式"},"children":[{"data":{"id":"ddfdtzhf3ts0","created":1760174633250,"text":"为了避免请求发送者与多个请求处理者耦合在一起，将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链；当请求发生时，可将请求沿着这条链传递，直到有对象处理"},"children":[]},{"data":{"id":"ddfdw45ssg00","created":1760174800160,"text":"优点"},"children":[{"data":{"id":"ddfdweob2k80","created":1760174823047,"text":"降低对象之间的耦合度"},"children":[]},{"data":{"id":"ddfdwj09s480","created":1760174832477,"text":"增强系统的可扩展性"},"children":[]},{"data":{"id":"ddfdwlzqf8g0","created":1760174838975,"text":"增强给对象指派责任的灵活性"},"children":[]},{"data":{"id":"ddfdwr3jzmo0","created":1760174850090,"text":"责任链简化对象之间的连接"},"children":[]},{"data":{"id":"ddfdwur8x480","created":1760174858053,"text":"责任分担"},"children":[]}]},{"data":{"id":"ddfdwxulmsw0","created":1760174864786,"text":"缺点"},"children":[{"data":{"id":"ddfdx4kgdc00","created":1760174879410,"text":"对比较长的职责链，请求的处理可能涉及多个处理对象，系统性能将受到一定影响·"},"children":[]},{"data":{"id":"ddfdxijiei80","created":1760174909828,"text":"职责链建立的合理性要靠客户端保证，增加客户端的复杂度，可能会由于职责链的错误设置导致系统出错，如可能会造成循环调用"},"children":[]}]}]}]},{"data":{"id":"deiieneyj6g0","created":1764148375377,"text":"技术场景","expandState":"collapse"},"children":[{"data":{"id":"deiieznn7zk0","created":1764148402024,"text":"如何实现单点登录"},"children":[{"data":{"id":"deiifs8dme00","created":1764148464227,"text":"Single Sign On"},"children":[]},{"data":{"id":"deiih9l4sdc0","created":1764148580368,"text":"解决方案，以JWT为例"},"children":[{"data":{"id":"deiihi2jiq00","created":1764148598835,"text":"1、用户访问其它系统，会在网关判断token是否有效"},"children":[]},{"data":{"id":"deiij0ngqi00","created":1764148717646,"text":"2、如果token无效则会返回401（认证失败）前端跳转到登陆页面"},"children":[]},{"data":{"id":"deiijf1x2jk0","created":1764148748995,"text":"3、用户发送登录请求，返回浏览器一个token，浏览器把token保存到cookie"},"children":[]},{"data":{"id":"deiijq436ps0","created":1764148773071,"text":"4、再去访问其他服务的时候，都需要携带token，由网关统一验证后路由到目标服务"},"children":[]}]}]},{"data":{"id":"deiip7fcei80","created":1764149202578,"text":"权限认证"},"children":[{"data":{"id":"deiipdycjo80","created":1764149216787,"text":"介绍RBAC权限模型5张表的关系（用户、角色、权限）"},"children":[]},{"data":{"id":"deiipsfajeg0","created":1764149248287,"text":"权限框架：Spring security"},"children":[]}]},{"data":{"id":"deiiz79b6co0","created":1764149985854,"text":"控制上传数据的安全性"},"children":[{"data":{"id":"deije6dhbd40","created":1764151159392,"text":"使用非对称加密（或对称加密），给前端一个公钥让他把数据加密后传到后台，后台负责解密后处理数据"},"children":[{"data":{"id":"deijeumnysg0","created":1764151212190,"text":"文件很大建议使用对称加密，不过不能保存敏感信息"},"children":[]},{"data":{"id":"deijflb1rqo0","created":1764151270261,"text":"文件较小，要求安全性高，建议采用非对称加密"},"children":[]}]}]},{"data":{"id":"deijki7wkv40","created":1764151655361,"text":"项目中遇到哪些棘手的问题"},"children":[{"data":{"id":"deijl91yjew0","created":1764151713775,"text":"1、什么背景，什么技术问题"},"children":[]},{"data":{"id":"deijle0fy4o0","created":1764151724567,"text":"2、过程（解决问题的过程）"},"children":[]},{"data":{"id":"deijllk5j9k0","created":1764151740997,"text":"3、最终落地的方案"},"children":[]},{"data":{"id":"deijmq2y3vc0","created":1764151829204,"text":"问题"},"children":[{"data":{"id":"deijmrdcesg0","created":1764151832010,"text":"1、设计模式"},"children":[{"data":{"id":"deijmv1vzps0","created":1764151840024,"text":"工厂"},"children":[]},{"data":{"id":"deijmwg103s0","created":1764151843056,"text":"策略"},"children":[]},{"data":{"id":"deijmxhd2k80","created":1764151845313,"text":"责任链"},"children":[]}]},{"data":{"id":"deijmzpcifs0","created":1764151850150,"text":"2、线上BUG"},"children":[{"data":{"id":"deijn2l83o00","created":1764151856431,"text":"CPU飙高"},"children":[]},{"data":{"id":"deijn53k9e00","created":1764151861893,"text":"内存泄露"},"children":[]},{"data":{"id":"deijn8296qo0","created":1764151868345,"text":"线程死锁"},"children":[]}]},{"data":{"id":"deijnb2t9ww0","created":1764151874909,"text":"3、调优"},"children":[{"data":{"id":"deijnnfmsg80","created":1764151901805,"text":"慢接口"},"children":[]},{"data":{"id":"deijns9ww5c0","created":1764151912343,"text":"慢SQL"},"children":[]},{"data":{"id":"deijnz2gfjs0","created":1764151927130,"text":"缓存方案"},"children":[]}]},{"data":{"id":"deijo89u3ds0","created":1764151947167,"text":"4、组件封装"},"children":[{"data":{"id":"deijob5uumg0","created":1764151953457,"text":"分布式锁"},"children":[]},{"data":{"id":"deijod6ascw0","created":1764151957837,"text":"接口幂等"},"children":[]},{"data":{"id":"deijolwnjfk0","created":1764151976845,"text":"分布式事务"},"children":[]},{"data":{"id":"deijope3lbs0","created":1764151984430,"text":"支付通用"},"children":[]}]}]}]},{"data":{"id":"dejazas3b0w0","created":1764228984598,"text":"项目日志如何采集"},"children":[{"data":{"id":"dejazi132lk0","created":1764229000379,"text":"搭建ELK日志采集系统"},"children":[{"data":{"id":"dejazm2gu7c0","created":1764229009170,"text":"Elasticsearch是全文搜索分析引擎，可以对数据存储、搜索、分析"},"children":[]},{"data":{"id":"dejazz7vuow0","created":1764229037796,"text":"Logstash是一个数据收集引擎，可以动态收集数据，可以对数据进行过滤、分析，将数据存储到指定的位置"},"children":[]},{"data":{"id":"dejb0eia7ps0","created":1764229071076,"text":"Kibana是一个数据分析和可视化平台，配合Elasticsearch对数据进行搜索，分析，图表化展示"},"children":[]}]}]},{"data":{"id":"dejb1xvpov40","created":1764229191611,"text":"查看日志的命令"},"children":[{"data":{"id":"dejb2frduxs0","created":1764229230531,"text":"实时监控日志的变化"},"children":[{"data":{"id":"dejb3zcy2nc0","created":1764229351558,"text":"实时监控某一个日志文件的变化：tail -f xx.log"},"children":[{"data":{"id":"dejb4lkl5so0","created":1764229399909,"text":"实时监控日志最后100行日志：tail -n 100 -f xx.log"},"children":[]}]}]},{"data":{"id":"dejb51bim3c0","created":1764229434190,"text":"按照行号查询"},"children":[{"data":{"id":"dejb53zgmu80","created":1764229439991,"text":"查询日志尾部最后100行日志：tail -n 100 xx.log"},"children":[]},{"data":{"id":"dejb5lrj1g00","created":1764229478693,"text":"查询日志头部开始100行日志：head -n 100 xx.log"},"children":[]},{"data":{"id":"dejb5ulkzpc0","created":1764229497925,"text":"查询某一个日志行号区间： cat -n xx.log | tail -n +100 | head -n 100（查询100行至200行的日志） "},"children":[]}]},{"data":{"id":"dejb6n7kmjc0","created":1764229560204,"text":"按照关键字找日志的信息"},"children":[{"data":{"id":"dejb6va48g00","created":1764229577773,"text":"查询日志文件中包含debug的日志行号：cat -n xx.log | grep “debug”"},"children":[]}]},{"data":{"id":"dejb7hlynds0","created":1764229626378,"text":"按照日期查询"},"children":[{"data":{"id":"dejb7lbr2g00","created":1764229634468,"text":"sed -n'/2023-05-18 14:22:31,070/,/2023-05-18 14:27:14.158/p' xx.log"},"children":[]}]},{"data":{"id":"dejb8qy3exc0","created":1764229725067,"text":"日志太多，处理方式"},"children":[{"data":{"id":"dejb8v6fmdc0","created":1764229734278,"text":"分页查询日志信息：cat -n xx.log | grep \"debug\" | more"},"children":[]},{"data":{"id":"dejb9c6bye80","created":1764229771277,"text":"筛选过滤以后，输出到一个文件：cat -n xx.log | grep \"debug\" > debug.txt"},"children":[]}]}]}]}]},"template":"right","theme":"fresh-blue-compat","version":"1.4.43"}